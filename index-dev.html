<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <title>dmax notebook asserts — index-dev.html</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    html,
    body {
      height: 100%;
      margin: 0;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
    }

    header {
      padding: 8px 12px;
      background: #0f172a;
      color: #e2e8f0;
      display: flex;
      align-items: center;
      gap: 12px;
      position: sticky;
      top: 0;
      z-index: 1000;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    #summary {
      margin-left: auto;
      font-weight: 600;
    }

    main {
      display: grid;
      grid-template-rows: auto 1fr;
      height: calc(100% - 0px);
    }

    #out {
      padding: 12px;
      white-space: pre-wrap;
      word-break: break-word;
      margin: 0;
    }

    .note {
      color: #475569;
      font-style: italic;
      padding: 8px 12px;
      border-bottom: 1px solid #e2e8f0;
      background: #f8fafc;
    }

    .chk.pass {
      color: #16a34a;
    }

    .chk.fail {
      color: #dc2626;
    }
  </style>
</head>

<body>
  <header>
    <div id="summary">Tests 0: Failed 0, Total 0</div>
  </header>
  <main>
    <div class="note">Output is mirrored from console.log/error</div>
    <pre id="out"></pre>
    <div id='foo' hidden>good</div>
  </main>
  <script>
    // Mirror console to <pre>, count tests
    (function () {
      const out = document.getElementById('out');
      const summary = document.getElementById('summary');
      let pass = 0, fail = 0, total = 0;
      const orig = { log: console.log, error: console.error, warn: console.warn };
      function toText(v) {
        try {
          if (typeof v === 'string') return v;
          if (v && typeof v === 'object') return JSON.stringify(v);
          return String(v);
        } catch (_) { return String(v); }
      }
      function append(args) {
        const isPass = args && args.length && (args[0] === '✓' || args[0] === '\u2713');
        const isFail = args && args.length && (args[0] === '✗');
        const line = args.map(toText).join(' ');
        const div = document.createElement('div');
        if (isPass || isFail) {
          const chk = document.createElement('span');
          chk.textContent = args[0];
          chk.className = 'chk ' + (isPass ? 'pass' : 'fail');
          div.appendChild(chk);
          const rest = args.slice(1).map(toText).join(' ');
          div.appendChild(document.createTextNode(' ' + rest));
        } else {
          div.textContent = line;
        }
        out.appendChild(div);
        if (isPass) { pass++; total++; }
        else if (isFail) { fail++; total++; }
        summary.textContent = `Tests ${total}: Passed ${pass}, Failed ${fail}`;
      }
      console.log = (...args) => { try { append(args); } finally { orig.log.apply(console, args); } };
      console.error = (...args) => { try { append(args); } finally { orig.error.apply(console, args); } };
      console.warn = (...args) => { try { append(args); } finally { orig.warn.apply(console, args); } };
    })();
  </script>
  <script>
    // @js-check
    //-------------test code-------------------
    stableStringify = (val) => {
      if (Array.isArray(val)) return `[${val.map(stableStringify).join(',')}]`;
      if (val && typeof val === 'object' && !(val instanceof Date)) {
        return `{${Object.keys(val).sort().map(key => `${JSON.stringify(key)}:${stableStringify(val[key])}`).join(',')}}`;
      }
      return JSON.stringify(val);
    };
    deepEqual = (a, b) => {
      if (a === b) return true;
      const aObj = a && typeof a === 'object';
      const bObj = b && typeof b === 'object';
      if (!aObj && !bObj) return Object.is(a, b);
      return stableStringify(a) === stableStringify(b);
    };
    fmt = (val) => (typeof val === 'string' ? `'${val}'` : stableStringify(val));
    assert = (fn, args, expected, label) => {
      const fname = fn && fn.name ? fn.name : '(anonymous)';
      const head = label ? `${fname} — ${label}` : fname;
      try {
        const actual = Array.isArray(args) ? fn(...args) : fn(args);
        const pass = deepEqual(actual, expected);
        if (pass)
          console.log('✓', head, '>>>', fmt(actual));
        else
          console.error('✗', head, '>>> expected:', fmt(expected), 'actual:', fmt(actual));
      } catch (err) {
        console.error('✗', head, '>>> threw:', fmt(err), '>>> expected:', fmt(expected));
      }
    };

    //------- lib code starts here-------------
    // Returns the index of the first found char (from chars) in the s, or -1 if none found,
    // then you can check s[returnedIndex] to see which char it is.
    function indexFirst(s, chars, pos = 0) {
      let i, first = s.length
      for (let c of chars) if ((i = s.indexOf(c, pos)) != -1 && i < first) first = i
      return first === s.length ? -1 : first
    }

    assert(indexFirst, ['abcdefg', ['x', 'y', 'z']], -1, 'none found');
    assert(indexFirst, ['abcdefg', ['x', 'c', 'z']], 2, 'one found');
    assert(indexFirst, ['abcdefgabc', ['a', 'b', 'c'], 3], 7, 'multiple found with pos');
    assert(indexFirst, ['abcdefg', ['a'], 10], -1, 'pos out of range');

    const CAMEL_NAMES = new Map()
    function kebabToCamel(s) {
      if (!s) return s
      let p = s.indexOf('-')
      if (p < 0) return s
      let res = CAMEL_NAMES.get(s)
      if (res) return res
      res = s.slice(0, p)
      while (p >= 0 && ++p < s.length) {
        if (s[p] == '-') continue;
        res += s[p].toUpperCase()
        if (++p < s.length)
          res += s.slice(p, (p = s.indexOf('-', p)) == -1 ? s.length : p)
      }
      CAMEL_NAMES.set(s, res)
      return res
    }

    assert(kebabToCamel, ['foo-bar'], 'fooBar', 'basic case');
    assert(kebabToCamel, ['-bar'], 'Bar', 'lead single');
    assert(kebabToCamel, ['bar-'], 'bar', 'trail single');
    assert(kebabToCamel, ['multi-part-key'], 'multiPartKey', 'multi part');
    assert(kebabToCamel, ['-'], '', 'single dash');
    assert(kebabToCamel, ['--'], '', 'multi dashes only');
    assert(kebabToCamel, ['--leading--dashes'], 'LeadingDashes', 'leading dashes');
    assert(kebabToCamel, ['trailing--dashes-'], 'trailingDashes', 'trailing dashes');

    const DOT = '.'
    const NAME_DELIMS = [DOT] //'[', ']' // @wip parse brackets later
    const SIGN = 's', PROP = DOT, ID = '#', SPEC = '_', NOT = '!', EV = '~' // @wip add support for EV 

    const WIN = '_window'; DOC = '_document'; FRM = '_form'; INTR = '_interval'; TIMT = '_timeout'
    const SPECIALS = [WIN, DOC, FRM, INTR, TIMT]

    function isSpecial(n) {
      if (n.startsWith(SPEC)) for (const s of SPECIALS) { if (n.startsWith(s, 1)) return true }
      return false
    }

    function isPropOrEvent(n) {
      return n.startsWith(ID) || n.startsWith(DOT) || isSpecial(n)
    }

    // @WIP: Phase 1
    // data-dump@foo-bar-signal+#tpl-id instead of data-dump@foo-bar-signal#tpl-id
    // data-class+zebra-even+!zebra-odd instead of data-class:+zebra-even:~zebra-odd
    // ^ instead of __ for mods: data-get^no-cache:posts^replace+user.name^query.username instead of data-get__no-cache:posts__replace+user.name__query.username
    // @WIP: Phase 2
    // data-sign instead of data-def, data-sub, data-sync
    // data-sign:foo:bar='console.log('side effect!'); return 42'
    // data-sign:target@source-signal@.source-prop
    // data-sign:targ@#some.prop@~click // click sets the targ to ev.detail by default or you can data-sign:targ@#some.prop@~click.target.name
    // data-sign:targ@#some.prop@~click='pr ? pr : ev?.target.name ?? null' where pr is additional parameter we are passing to (dm, el, sg, ev, pr) => '...'
    const MOD = '^', TARG = ':', TRIG = '@', STAT = '?', ADD = '+'
    const ALL = [MOD, TARG, TRIG, STAT, ADD]
    const MODS = [MOD]
    const KIND = [MOD, SIGN, PROP, EV, ID, SPEC]

    // Returns {kind:KIND, not:null|bool, root:null|name, path:null|[...names] } or null for invalid item
    function parseItem(aName, type, n, pos = 0) {
      if (!n) return null

      let p = pos
      while (n.startsWith(NOT, p)) ++p
      let not = p == 0 ? null : p % 2 != 0

      let d = n.indexOf(DOT, p)
      let root = d < 0 ? (p == 0 ? n : n.slice(p)) : n.slice(p, d)
      if (root) root = kebabToCamel(root)

      if (type === MOD) {
        if (!root) { console.error('[dmax] Error: Mod name should not be empty for:', n, 'in:', aName); return null }
        if (d < 0 || d + 1 >= n.length) return { kind: MOD, not, root, path: null } // accepts trailing dot in ^mod-foo.
        let val = n.indexOf(DOT, p = d + 1) < 0 ? kebabToCamel(n.slice(p)) : parseItem(aName, TRIG, n, p) // recurse for mod val being a signal
        return { kind: MOD, root, not, path: val }
      }

      let kind = SIGN
      if (root && root.length > 0 && (root[0] === ID || isSpecial(root))) {
        kind = root[0] // ID or SPEC
        root = root.slice(1)
        if (!root) { console.error('[dmax] Error: The', kind, 'element should have a non empty name:', n, 'in:', aName); return null }
      }

      if (d < 0) {
        if (!root && kind === SIGN) { console.error('[dmax] Error: Signal should have a non empty name:', n, 'in:', aName); return null }
        return { kind, not, root, path: null }
      }

      if (!root) kind = PROP
      if (d + 1 == n.length) return { kind, not, root, path: null }

      p = d + 1
      let path = []
      while (p >= 0 && p < n.length) {
        d = n.indexOf(DOT, p)
        const part = n.slice(p, p = d < 0 ? n.length : d)
        if (!part) { console.error('[dmax] Error: Path should not have an empty part:', n, 'in:', aName); return null }
        path.push(kebabToCamel(part))
        ++p
      }
      return { kind, not, root, path }
    }

    assert(parseItem, ['XXX', TRIG, '#hey.foo.bar-baz'], { "kind": "#", "not": null, "path": ["foo", "barBaz"], "root": "hey" }, 'trigger #id.prop.prop')
    assert(parseItem, ['XXX', TARG, 'foo-bar'], { "kind": "s", "not": null, "path": null, "root": "fooBar" }, 'target kebab to camel');
    assert(parseItem, ['XXX', TRIG, '#el.some.prop'], { "kind": "#", "not": null, "path": ["some", "prop"], "root": "el" }, 'trigger id and path');
    assert(parseItem, ['XXX', TRIG, '!foo'], { "kind": "s", "not": true, "path": null, "root": "foo" }, 'negated once');
    assert(parseItem, ['XXX', TRIG, '!!foo'], { "kind": "s", "not": false, "path": null, "root": "foo" }, 'double negation even');
    assert(parseItem, ['XXX', TARG, 'foo.'], { "kind": "s", "not": null, "path": null, "root": "foo" }, 'trailing dot yields null path');
    assert(parseItem, ['XXX', TARG, 'a..b'], null, 'error: empty middle segment');
    assert(parseItem, ['XXX', TARG, 'foo.bar-baz.qux-quux'], { "kind": "s", "not": null, "path": ["barBaz", "quxQuux"], "root": "foo" }, 'path segments kebab->camel');
    assert(parseItem, ['XXX', MOD, '!eq.3'], { "kind": "^", "not": true, "path": "3", "root": "eq" }, 'mod with negation and numeric path');
    assert(parseItem, ['XXX', MOD, '!eq.'], { "kind": "^", "not": true, "path": null, "root": "eq" }, 'mod with negation and dot at the end permitted');
    assert(parseItem, ['XXX', TARG, ''], null, 'error: empty name returns nulls');
    assert(parseItem, ['YYY', TARG, '.'], { "kind": PROP, "not": null, "path": null, "root": "" }, 'error: empty name returns nulls');

    function parse(aName, p = 'data-'.length, it = ALL) {
      let items = {}, modItems = null
      while (p >= 0 && p < aName.length) {
        if ((p = indexFirst(aName, it, p)) == -1) { p = aName.length; break }
        let t = aName[p], item = null
        if (++p < aName.length) {
          let end = indexFirst(aName, ALL, p)
          let name = aName.slice(p, p = end != -1 ? end : aName.length)
          if (name) item = parseItem(aName, t, name)
        }

        if (!item) continue // skip null/errors, avoid later null checks

        let ts = items[t] ??= []
        if (t == MOD) {
          ts.push(item);
          if (p >= aName.length || (it === MODS && aName[p] != MOD)) return [items, p]
        } else if (p >= aName.length || aName[p] != MOD) {
          item.mods = items[MOD] ?? null // set to glob mods if any
          ts.push(item);
        } else {
          [modItems, p] = parse(aName, p, MODS)
          let mods = modItems?.[MOD] ?? null
          if (items[MOD]) { // put glob mods if any into local mods but don't override
            if (!mods) mods = items[MOD]
            else {
              let modCount = mods.length
              for (const gm of items[MOD]) {
                let skipGlobal = false
                for (let i = 0; i < modCount; ++i)
                  if (mods[i].root === gm.root) { skipGlobal = true; break }
                if (!skipGlobal) mods.push(gm)
              }
            }
          }
          item.mods = mods
          ts.push(item)
        }
      }

      if (p < aName.length) console.warn('[dmax] Warning: Not everything is parsed "', aName.slice(p), '" in', aName)
      return [items, p]
    }

    assert(parse, ['data-def'], [{}, 8], 'empty')
    assert(parse, ['data-sub:'], [{}, 9], 'single empty')
    assert(parse, ['data-sub:.'], [{ ":": [{ "kind": ".", "mods": null, "not": null, "path": null, "root": "" }] }, 10], 'default prop')
    assert(parse, ['data-sub^mod'], [{ "^": [{ "kind": "^", "not": null, "path": null, "root": "mod" }] }, 12], 'global mod')
    assert(parse, ['data-sub^mod.some-foo.value^!eq.3'], [{ "^": [{ "kind": "^", "not": null, "path": { "kind": "s", "not": false, "path": ["value"], "root": "someFoo" }, "root": "mod" }, { "kind": "^", "not": true, "path": "3", "root": "eq" }] }, 33], '2 global mods')
    assert(parse, ['data-sub^mod^@hey^foo:bar'], [{ ":": [{ "kind": "s", "mods": [{ "kind": "^", "not": null, "path": null, "root": "mod" }], "not": null, "path": null, "root": "bar" }], "@": [{ "kind": "s", "mods": [{ "kind": "^", "not": null, "path": null, "root": "foo" }, { "kind": "^", "not": null, "path": null, "root": "mod" }], "not": null, "path": null, "root": "hey" }], "^": [{ "kind": "^", "not": null, "path": null, "root": "mod" }] }, 25], '2 global mods and item with mod with item')
    assert(parse, ['data-sub@!xxx@!'], [{ "@": [{ "kind": "s", "mods": null, "not": true, "path": null, "root": "xxx" }] }, 15], 'not name and not empty')
    assert(parse, ['data-sub:xxx:'], [{ ":": [{ "kind": "s", "mods": null, "not": null, "path": null, "root": "xxx" }] }, 13], 'single name')
    assert(parse, ['data-sub::'], [{}, 10], '2 empties')
    assert(parse, ['data-sub:foo^'], [{ ":": [{ "kind": "s", "mods": null, "not": null, "path": null, "root": "foo" }] }, 13], 'name+empty mod')
    assert(parse, ['data-sub:foo^^'], [{ ":": [{ "kind": "s", "mods": null, "not": null, "path": null, "root": "foo" }] }, 14], 'name+2 empty mods')
    assert(parse, ['data-sub:foo-bar^bax.3'], [{ ":": [{ "kind": "s", "mods": [{ "kind": "^", "not": null, "path": "3", "root": "bax" }], "not": null, "path": null, "root": "fooBar" }] }, 22], 'item^mod')
    assert(parse, ['data-sub:foo-bar^bax.3@!something^nice'], [{ ":": [{ "kind": "s", "mods": [{ "kind": "^", "not": null, "path": "3", "root": "bax" }], "not": null, "path": null, "root": "fooBar" }], "@": [{ "kind": "s", "mods": [{ "kind": "^", "not": null, "path": null, "root": "nice" }], "not": true, "path": null, "root": "something" }] }, 38], 'item^mod@item2^mod')
    assert(parse, ['data-sub^ge.2^le.5@foo^le.4'], [{ "@": [{ "kind": "s", "mods": [{ "kind": "^", "not": null, "path": "4", "root": "le" }, { "kind": "^", "not": null, "path": "2", "root": "ge" }], "not": null, "path": null, "root": "foo" }], "^": [{ "kind": "^", "not": null, "path": "2", "root": "ge" }, { "kind": "^", "not": null, "path": "5", "root": "le" }] }, 27], 'combine/do not override global mods into the item')
    assert(parse, ['data-sub^hey@foo:bar+bax'], [{ "+": [{ "kind": "s", "mods": [{ "kind": "^", "not": null, "path": null, "root": "hey" }], "not": null, "path": null, "root": "bax" }], ":": [{ "kind": "s", "mods": [{ "kind": "^", "not": null, "path": null, "root": "hey" }], "not": null, "path": null, "root": "bar" }], "@": [{ "kind": "s", "mods": [{ "kind": "^", "not": null, "path": null, "root": "hey" }], "not": null, "path": null, "root": "foo" }], "^": [{ "kind": "^", "not": null, "path": null, "root": "hey" }] }, 24], 'push all global mods to items')

    function isObjEmpty(o) {
      for (const _ in o) return false
      return true
    }

    const RETURN_THEN = [' ', '(', '{', ';', '[', '"', '\'', '\n', '\r', '\t']
    const SIGN_ARGS = ['dm', 'el']
    const TRIG_ARGS = ['dm', 'el', 'ev', 'sg', 'detail']

    function compileFn(aVal, aName, args) {
      let val = '' + aVal
      var r = val.indexOf('return')
      let body = r != -1 && (r + 6 >= val.length || indexFirst(val, RETURN_THEN, r + 6) == r + 6) ? val : `return(${val})`
      body = `try{ ${body} }catch(e){ console.error('[dmax] Error: eval ${aName} value as function:', e.message, '>>>', ${val}); return }`
      let fn;
      try { fn = Function(...args, body) }
      catch (e) { console.error(`Error compiling ${aName} value to function:`, e.message, '>>>', val); return }
      return fn;
    }

    const _dm = new Map()
    const DM = new Proxy({}, {
      get: (_, key) => _dm.get(key),
      set: (_, key, val) => { _dm.set(key, val); return true; },
      has: (_, key) => _dm.has(key),
      ownKeys: () => Array.from(_dm.keys()),
      getOwnPropertyDescriptor: (_, key) =>
        _dm.has(key) ? { value: _dm.get(key), enumerable: true, configurable: true } : undefined
    });

    // - data-def='{foo: {bar: "hey"}, baz: 1}' // top level fields to signals
    // - data-def:foo='{bar: "hey"}' // foo signal
    // - data-def:foo:baz='`js expr ${42}`' // eval expr as Function body and set to all signals
    // - data-def:foo='el.Value * dm.bar' // you may use other signals and element props
    function dDef(el, aName, aVal) {
      let [it, _p] = parse(aName)
      let tars = it[TARG]
      delete it[TARG]
      if (!isObjEmpty(it)) console.warn('[dmax] Warning: Supports only targets but found more:', aName)
      let val = aVal ? compileFn(aVal, aName, SIGN_ARGS)(DM, el) : null
      if (tars) {
        for (const t of tars) {
          if (t.kind != SIGN) { console.error('[dmax] Error: Only signal targets are supported but found:', t, 'in', aName); continue }
          if (t.mods) console.warn('[dmax] Warning: Mods are not supported:', mods, 'in', aName);
          _dm.set(t.root, val)
        }
      } else if (val && typeof val === 'object') {
        for (const t in val)
          _dm.set(kebabToCamel(t), val[t])
      } else {
        console.error('[dmax] Error: Attribute', aName, 'value should contain object with signal fields, but found', aVal)
      }
    }

    const _sign = (nam, val) => { _dm.clear(); dDef(null, nam, val); return DM };
    const _signEl = (el, nam, val) => { _dm.clear(); dDef(el, nam, val); return DM };
    const _signDmSet = (k, v, nam, val) => { _dm.clear(); DM[k] = v; dDef(null, nam, val); return DM };
    assert(_sign, ['data-def', '{foo: {bar: "hey"}, baz: 1}'], { "baz": 1, "foo": { "bar": "hey" } }, '2 value signals')
    assert(_sign, ['data-def:foo', '{bar: "hey"}'], { "foo": { "bar": "hey" } }, 'signal = value')
    assert(_sign, ['data-def:foo-bar:baz'], { "baz": null, "fooBar": null }, 'signals')
    assert(_sign, ['data-def:foo-bar:baz', '`Mamma Mia ${42}`'], { "baz": "Mamma Mia 42", "fooBar": "Mamma Mia 42" }, 'bonkers')

    assert(_signEl, [{ "name": "John" }, 'data-def:foo', '"Hey, " + el.name'], { "foo": "Hey, John" }, 'using el')
    assert(_signDmSet, ['name', 'Noize', 'data-def:greet', '"Hey, " + dm.name'], { "name": "Noize", "greet": `Hey, Noize` }, 'using dm')

    function getElById(id, aName) {
      if (!id) return null
      const el = document.getElementById(id)
      if (!el) console.error(`[dmax] Error: element #${id} from ${aName} is not found`)
      return el;
    };

    const _getElById = (id, aName) => getElById(id, aName)?.textContent ?? null;

    assert(_getElById, ['foo', 'data-sub:#foo@bar'], 'good', 'get existing elem')

    function getAutoProp(el) {
      if (!el) return 'textContent'
      const t = el.type, n = el.tagName
      return t === 'checkbox' || t === 'radio' ? 'checked'
        : n === 'INPUT' || n === 'SELECT' || n === 'TEXTAREA' ? 'value'
          : 'textContent'
    }

    // Default event for element (tags are upper-case per W3C; no toUpperCase needed)
    function getAutoEvent(el) {
      if (!el) return 'click'
      let n = el.tagName
      return n === 'FORM' ? 'submit'
        : n === 'INPUT' || n === 'SELECT' || n === 'TEXTAREA' ? 'change'
          : 'input'
    }

    function isNil(v) { return v === null || v === undefined }

    function getNestedVal(obj, path, depth = -1) {
      let v = obj
      if (isNil(v) || !path) return [v, 0]
      let n = depth == -1 || depth > path.length ? path.length : depth
      for (let i = 0; i < n; ++i) if (isNil(v = v[path[i]])) return [v, i + 1]
      return [v, n]
    }

    assert(getNestedVal, [getElById('foo', 'xxx'), ['textContent']], ['good', 1], 'depth 1')
    assert(getNestedVal, [{ foo: { bar: { baz: 42 } } }, ['foo', 'bar', 'baz']], [42, 3], '42')
    assert(getNestedVal, [{ foo: { bar: null } }, ['foo', 'bar', 'baz']], [null, 2], 'null')

    const VAL_CHANGE_DEPTH_MAX = 32
    function valChangedDeep(before, after, depth = 0) {
      if (depth >= VAL_CHANGE_DEPTH_MAX) { console.warn('[dmax] Warning: too deep to compare for signal value change, consider it changed, stopped at:', VAL_CHANGE_DEPTH_MAX); return true }
      const b = before, a = after
      if (Array.isArray(b)) { // means b is also an array
        if (!Array.isArray(a) || b.length != a.length) return true
        for (let i = 0; i < b.length; ++i) if (valChangedDeep(b[i], a[i], ++depth)) return true
      } else if (b && typeof b === 'object') {
        if (!a || typeof a !== 'object') return true
        for (const k in b) {
          if (!(k in a)) return true
          if (valChangedDeep(b[k], a[k], ++depth)) return true
        }
        for (const k in a) if (!(k in b)) return true
      } else if (a !== b) return true
      return false
    }

    assert(valChangedDeep, ['foo', 'bar'], true, '2 diff strings')
    assert(valChangedDeep, [null, []], true, 'null vs empty arr')
    assert(valChangedDeep, [[], []], false, '2 empty arrays')
    assert(valChangedDeep, [[42], [42]], false, '2 value arrays')
    assert(valChangedDeep, [{ foo: 1 }, { foo: 1 }], false, '2 simple objects')
    assert(valChangedDeep, [{ foo: 1 }, { foo }], true, '2 simple non equal objects')
    assert(valChangedDeep, [{ foo: 1 }, null], true, 'object and null')
    assert(valChangedDeep, [{ foo: 1, bar: [{ baz: [42] }] }, { foo: 1, bar: [{ baz: [42] }] }], false, 'complex objects')
    assert(valChangedDeep, [[1, 5, 6, 7], [5, 6, 7, 8]], true, 'flat diff arrays')
    assert(valChangedDeep, [[5, 6, 7, 8], [5, 6, 7, 8]], false, 'flat equal arrays')

    function setProp(el, aName, tar, val) {
      if (tar.kind != ID && tar.kind != PROP) { console.error('[dmax] Error: Unsupported target kind for setting the property', tar, 'in', aName); return }
      let obj = tar.kind == ID ? getElById(tar.root, aName) : el
      let path = tar.path, prop = null
      if (!path)
        prop = getAutoProp(el);
      else if (path.length > 0) {
        [obj, _] = getNestedVal(obj, path, path.length - 1)
        prop = path[path.length-1]
      }
      if (!obj || !prop) { console.error('[dmax] Error setting non existing property for: ', tar, 'in', aName); return }
      try {
        if (valChangedDeep(obj[prop], val)) obj[prop] = val;
      } catch (e) {
        console.error('[dmax] Error: Failed to set property:', e.message, '>>>', tar, 'on', el);
      }
      return obj[prop]
    }

    assert(setProp, [{ value: 'Answer42' }, 'data-eval:.', { kind: PROP, not: null, root: "", path: null }, 'Seaman!'],
      'Seaman!', 'default prop')
    assert(setProp, [null, 'data-eval:#foo.', { kind: ID, not: null, root: 'foo', path: null }, 'Seaman!'],
      'Seaman!', '#foo default prop')
    assert(setProp, [null, 'data-eval:#foo.style.color', { kind: ID, not: null, root: 'foo', path: ['style', 'color'] }, 'lime'],
      'lime', '#foo nested prop')

    const EMPTY_ARR = []
    function diffShapeShallow(before, after) {
      let b = before, a = after
      if (!b || typeof b != 'object') b = EMPTY_ARR
      if (!a || typeof a != 'object') a = EMPTY_ARR

      if (Array.isArray(b)) {
        if (Array.isArray(a))
          return a.length == b.length ? null : a.length > b.length
            ? { addedRange: [b.length, a.length - b.length] }
            : { removedRange: [a.length, b.length - a.length] }
        return { added: Object.keys(a), removedRange: [0, b.length] }
      }

      if (Array.isArray(a))
        return { removed: Object.keys(b), addedRange: [0, a.length] }

      // Shallow object key shape diff: track added/removed keys only
      let added = [], removed = []
      for (const k in a) if (!(k in b)) added.push(k)
      for (const k in b) if (!(k in a)) removed.push(k)
      return added.length ? (removed.length ? { added, removed } : { added }) : (removed.length ? { removed } : null)
    }

    assert(diffShapeShallow, ['a', 'b'], null, 'non-objects => no shape change')
    assert(diffShapeShallow, [[1, 2], [3, 4]], null, 'arrays same length')
    assert(diffShapeShallow, [[1, 2], [1, 2, 3, 4, 5]], { addedRange: [2, 3] }, 'arrays added tail')
    assert(diffShapeShallow, [[1, 2, 3, 4, 5], [1, 2]], { removedRange: [2, 3] }, 'arrays removed tail')
    assert(diffShapeShallow, [[], []], null, 'arrays both empty')
    assert(diffShapeShallow, [{ a: 1 }, { a: 2 }], null, 'objects same keys different values')
    assert(diffShapeShallow, [{ a: 1 }, { a: 1, b: 2 }], { added: ['b'] }, 'objects add key')
    assert(diffShapeShallow, [{ a: 1, b: 2 }, { a: 1 }], { removed: ['b'] }, 'objects remove key')
    assert(diffShapeShallow, [{ a: 1, b: 2 }, { a: 1, c: 3 }], { added: ['c'], removed: ['b'] }, 'objects add+remove')
    assert(diffShapeShallow, [[1, 2, 3], { a: 1, b: 2 }], { added: ['a', 'b'], removedRange: [0, 3] }, 'array to object')
    assert(diffShapeShallow, [{ a: 1, b: 2 }, [1, 2, 3]], { removed: ['a', 'b'], addedRange: [0, 3] }, 'object to array')

    function samePath(a, b) {
      if (a.length !== b.length) return false
      for (let i = 0; i < a.length; ++i)
        if (a[i] !== b[i]) return false
      return true
    }

    // If sg not exist in the _dm, then we will create it -> creating missing target on demand
    const SG_CHANGED = 0, SG_CHANGED_PLUS_SHAPE = 1, SG_SHAPE_CHANGED_ONLY = 2
    const _subs = new Map()
    function setSignalVal(aName, tar, val, ev) {
      console.assert(tar)
      const root = tar.root, path = tar.path
      console.assert(root)
      let sgVal = _dm.get(root), curVal = sgVal, parent = sgVal, d = 0, last = null
      if (path) {
        console.assert(path.length);
        [parent, d] = getNestedVal(parent, path, path.length - 1)
        if (!parent) { console.error('[dmax] Error: cannot set value to missing signal parent at:', root, 'at path:', path, 'at index:', d - 1, 'in:', aName); return }
        curVal = parent[last = path[d]]
      }

      // if change detected it means ALL parents of cur  and SOME of children changed
      if (!valChangedDeep(curVal, val)) return;

      const handlers = _subs.get(root);
      if (!handlers) {
        if (!path) _dm.set(root, val)
        else parent[last] = val
        return
      }

      // we need to change the value and THEN notify, so to avoid value preservation lets collect the handlers with changes first
      let collected = [], diffed = false, diff = null, pathDiffs = []
      for (const h of handlers) { // h.fn, h.mode, h.path
        const hp = h.path, mode = h.mode
        if (!hp) {
          if (!path && !diffed && mode !== SG_CHANGED) {// compare roots if it is the first time
            diffed = true
            diff = diffShapeShallow(curVal, val)
          }
          if (path || mode !== SG_SHAPE_CHANGED_ONLY || diff)
            collected.push([h, path ? null : diff]) // ignore diff later for NOTIFY_SG_CHANGE
          continue
        }

        // if some path value changed - filter out the handlers diverting from the path
        if (path) {
          const notifyParent = hp.length < path.length, minLen = notifyParent ? hp.length : path.length
          let skip = false
          for (let i = 0; i < minLen; ++i) if (skip = (path[i] != hp[i])) break
          if (skip) continue
          if (notifyParent) { collected.push([h, null]); continue }
          if (path.length == hp.length) {
            if (!diffed && mode !== SG_CHANGED) {
              diffed = true
              diff = diffShapeShallow(curVal, val)
            }
            if (mode !== SG_SHAPE_CHANGED_ONLY || diff)
              collected.push([h, diff])
            continue
          }
        }

        // the hp has the longer path based on previous checks, we to check that it actually changed
        // first, check if we did this comparison before
        let hCol = null, p = null
        for (const col in collected) // check if the same 
          if ((p = col[0].path) && samePath(p, hp)) { hCol = col; break }

        let [pathCur, _] = getNestedVal(sgVal, hp), pathVal
        if (hCol) pathVal = hCol[2]
        else {
          [pathVal, _] = getNestedVal(val, hp)
          if (!valChangedDeep(pathCur, pathVal)) continue
        }

        let pathDiffed = false, pathDiff = null
        if (mode != SG_CHANGED) {
          for (const pd of pathDiffs) if (samePath(pd[0], hp)) { pathDiffed = true; pathDiff = pd[1]; break }
          if (!pathDiffed) pathDiffs.push(pathDiff = diffShapeShallow(pathCur, pathVal))
        }

        if (mode !== SG_SHAPE_CHANGED_ONLY || pathDiff)
          collected.push([h, pathDiff, pathVal])
      }

      if (!path) _dm.set(root, val)
      else parent[last] = val

      for (const hh of collected) // notify with new values and diff if asked for
        hh[0].fn(hh[0].mode === SG_CHANGED ? null : hh[1])

      // updateDebug(); // @wip don't bother until later
    }

    // @TEST register sink subscriber
    function _reg(root, path, mode, sink) {
      let arr = _subs.get(root)
      if (!arr) _subs.set(root, arr = []);
      arr.push({ fn: (d) => sink.push(d), mode, path });
    }

    function reset() { _subs.clear(); _dm.clear() }

    function tSetD() {
      reset();
      _dm.set('user', { name: 'Alice', age: 30 });
      const sh = [], nm = [], age = [], deep = [];
      _reg('user', null, SG_CHANGED_PLUS_SHAPE, sh);
      _reg('user', ['name'], SG_CHANGED_PLUS_SHAPE, nm);
      _reg('user', ['age'], SG_CHANGED_PLUS_SHAPE, age);
      _reg('user', ['name', 'first'], SG_CHANGED_PLUS_SHAPE, deep);
      setSignalVal('t', { root: 'user', path: ['name'] }, 'Bob');
      return { r: sh.length, nm: nm.length, age: age.length, deep: deep.length, val: _dm.get('user')?.name ?? null };
    }
    assert(tSetD, [], { r: 1, nm: 1, age: 0, deep: 0, val: 'Bob' }, 'path update, exact match');

    function tSetE() {
      reset();
      _dm.set('user', { children: [1, 2] });
      const c0 = [], c1 = [], c2 = [];
      _reg('user', ['children'], SG_CHANGED, c0);
      _reg('user', ['children'], SG_CHANGED_PLUS_SHAPE, c1);
      _reg('user', ['children'], SG_SHAPE_CHANGED_ONLY, c2);
      setSignalVal('t', { root: 'user', path: ['children'] }, [1, 2, 3, 4]);
      const d1 = c1.length ? c1[c1.length - 1] : null;
      const d2 = c2.length ? c2[c2.length - 1] : null;
      return { c0: c0.length, c1: c1.length, c2: c2.length, d1, d2, val: _dm.get('user')?.children };
    }
    assert(tSetE, [], { c0: 1, c1: 1, c2: 1, d1: { addedRange: [2, 2] }, d2: { addedRange: [2, 2] }, val: [1, 2, 3, 4] }, 'path update shape arrays');

    function tSetA() {
      reset()
      _dm.set('sg', 1);
      setSignalVal('t', { root: 'sg', path: null }, 2);
      return _dm.get('sg');
    }
    assert(tSetA, [], 2, 'root update no subs');

    function tSetB() {
      reset();
      _dm.set('sg', 'a');
      const c0 = [], c1 = [], c2 = [];
      _reg('sg', null, SG_CHANGED, c0);
      _reg('sg', null, SG_CHANGED_PLUS_SHAPE, c1);
      _reg('sg', null, SG_SHAPE_CHANGED_ONLY, c2);
      setSignalVal('t', { root: 'sg', path: null }, 'b');
      return { c0: c0.length, c1: c1.length, c2: c2.length, val: _dm.get('sg') };
    }
    assert(tSetB, [], { c0: 1, c1: 1, c2: 0, val: 'b' }, 'root content change notify vs shape');

    function tSetC() {
      reset();
      _dm.set('sg', [1, 2]);
      const c0 = [], c1 = [], c2 = [];
      _reg('sg', null, SG_CHANGED, c0);
      _reg('sg', null, SG_CHANGED_PLUS_SHAPE, c1);
      _reg('sg', null, SG_SHAPE_CHANGED_ONLY, c2);
      setSignalVal('t', { root: 'sg', path: null }, [1, 2, 3, 4]);
      const d1 = c1.length ? c1[c1.length - 1] : null;
      const d2 = c2.length ? c2[c2.length - 1] : null;
      return { c0: c0.length, c1: c1.length, c2: c2.length, d1, d2, val: _dm.get('sg') };
    }
    assert(tSetC, [], { c0: 1, c1: 1, c2: 1, d1: { addedRange: [2, 2] }, d2: { addedRange: [2, 2] }, val: [1, 2, 3, 4] }, 'root shape change arrays');

    let syncDepth = 0, MAX_SYNC_DEPTH = 32;
    function setSignal(_el, aName, tar, val, ev) {
      if (syncDepth++ > MAX_SYNC_DEPTH) {
        console.error(`[dmax] Error: Infinite loop detected for signal: ${tar} (depth > ${MAX_SYNC_DEPTH}) in ${aName}`)
        return
      }
      try { return setSignalVal(aName, tar, val, ev) } finally { syncDepth-- }
    }

    // // Track all event listeners and signal handlers for cleanup
    // _cleanupMap = new WeakMap();

    // @wip Use dSync for everything:
    // data-def -> data-sync:target0:target1='val'
    // data-sub -> data-sync:targ@sign@.prop@.ev~='val'
    // data-sync:.prop@sign
    // data-sync:@.prop:@sign='type === SIGNAL ? val * 2 : val * 0.5'
    // data-class -> data-sync:.class-list^add@sign@.prop='type == PROP ? cls1 : cls2'
    // data-class -> data-sync:.class-list^add.cls1@sign
    // data-class -> data-sync:.class-list^toggle.foo.bar@sign
    // data-class -> data-sync:.class-list^toggle@sign='cls2'
    // data-class -> data-sync:.class-list^remove.cls3@!sign'
    // data-disp  -> data-sync:style.display^_set.none@foo@.bar

    // function dSync(el, aName, aVal) {
    //   let [it, _p] = parse(aName)
    //   let tars = it[TARG]
    //   let trigs = it[TRIG]
    //   let globMods = it[MOD]
    //   delete it[TARG]; delete it[TRIG]; delete it[MOD];
    //   if (!isObjEmpty(it)) console.warn('[dmax] Warning: Supports only targets, triggers, mods but found more:', aName)
    //   if (!aVal) { console.error('[dmax] Error: in ', aName, 'it requires a value but found none', aVal); return }
    //   let fn = compileFn(aVal, aName, TRIG_ARGS)
    //   if (!fn) return

    //   let setters = []
    //   for (const tar of tars) {
    //     if (!tar || !tar.kind) continue
    //     let setter = tar.kind == SIGN
    //       ? (t, val, ev) => setSignal(el, aName, t, val, ev)
    //       : (t, val, _ev) => setProp(el, aName, t, val)
    //     setters.push(setter)
    //   }

    //   const handler = (ev, sg, detailArg) => {
    //     const detail = ev && ev.detail && ev.detail.change ? ev.detail.change : detailArg;
    //     const val = fn(DM, el, ev, sg, detail);
    //     if (!appliers || appliers.length === 0) return;
    //     try {
    //       for (const ap of appliers) if (ap) ap(val, ev);
    //     } catch (e) { console.error('[dmax] Error: Applier error', e); }
    //   };

    //   // Track listeners for cleanup
    //   let listeners = _cleanupMap.get(el);
    //   if (!listeners) _cleanupMap.set(el, listeners = []);
    //   for (let trig of trigs) {

    //     // build a decorated handler that supports modifier semantics: __prevent, __once, __debounce, __throttle, __and
    //     const makeDecorated = (hand, t) => {
    //       const { mods = {} } = t;
    //       const debMs = mods.debounce == null ? null : +mods.debounce;
    //       const thrMs = mods.throttle == null ? null : +mods.throttle;
    //       const once = 'once' in mods;
    //       const prevent = 'prevent' in mods;
    //       const andPath = mods.and ?? null;
    //       const guardEq = 'eq' in mods ? mods.eq : undefined;
    //       const guardNe = 'ne' in mods ? mods.ne : undefined;
    //       const guardGt = 'gt' in mods ? +mods.gt : undefined;
    //       const guardGe = 'ge' in mods ? +mods.ge : undefined;
    //       const guardLt = 'lt' in mods ? +mods.lt : undefined;
    //       const guardLe = 'le' in mods ? +mods.le : undefined;
    //       let timer = null;
    //       let last = 0;
    //       const decorated = function (ev, sg, detailArg) {
    //         if (prevent) ev?.preventDefault?.();
    //         const run = () => {
    //           if (andPath && !getSignalVal(String(andPath))) return;
    //           // Get subject value, apply negation if trigger is negated
    //           let subjectVal = t.type === 'signal' ? getSignalVal(String(t.name)) : ev?.detail?.ms;
    //           if (t.negated && t.type === 'signal') subjectVal = !subjectVal;
    //           if (guardEq !== undefined && String(subjectVal) !== String(guardEq)) return;
    //           if (guardNe !== undefined && String(subjectVal) === String(guardNe)) return;
    //           if (guardGt !== undefined && !(+subjectVal > guardGt)) return;
    //           if (guardGe !== undefined && !(+subjectVal >= guardGe)) return;
    //           if (guardLt !== undefined && !(+subjectVal < guardLt)) return;
    //           if (guardLe !== undefined && !(+subjectVal <= guardLe)) return;
    //           try { hand(ev, sg, detailArg); } catch (e) { console.error('[dmax] Error: Handler error', e); }
    //           if (once && decorated && decorated.remove) decorated.remove();
    //         };
    //         if (debMs != null) { clearTimeout(timer); timer = setTimeout(run, debMs); return; }
    //         if (thrMs != null) { const now = Date.now(); if (now - last >= thrMs) { last = now; run(); } return; }
    //         run();
    //       };
    //       return decorated;
    //     };

    //     if (trig.type === 'signal') {
    //       const rootRaw = String(trig.name).split('.')[0];
    //       const rootBase = (rootRaw.indexOf('[') !== -1) ? rootRaw.split('[')[0] : rootRaw;
    //       const root = toCamel(rootBase);
    //       const rootAlias = sigKey(rootBase);
    //       if (!SUBS.has(root)) SUBS.set(root, []);
    //       if (rootAlias !== root && !SUBS.has(rootAlias)) SUBS.set(rootAlias, []);
    //       const dec = makeDecorated(handler, trig);
    //       // allow removal for __once and other removals; handle both legacy function entries and object entries
    //       dec.remove = () => {
    //         const arr = SUBS.get(root) || [];
    //         SUBS.set(root, arr.filter(it => (typeof it === 'function' ? it !== dec : it.fn !== dec)));
    //         if (rootAlias !== root) { const arr2 = SUBS.get(rootAlias) || []; SUBS.set(rootAlias, arr2.filter(it => (typeof it === 'function' ? it !== dec : it.fn !== dec))); }
    //       };
    //       // support __shape modifier: register subscription object with optional path
    //       let entry = dec;
    //       if (trig.mods && ('shape' in trig.mods || 'content' in trig.mods)) {
    //         const sval = (trig.mods && 'shape' in trig.mods) ? ((trig.mods.shape === true || trig.mods.shape === 1) ? null : (trig.mods.shape != null ? String(trig.mods.shape) : null)) : null;
    //         entry = { fn: dec, mode: ('shape' in trig.mods ? 'shape' : 'content'), path: sval };
    //       }

    //       SUBS.get(root).push(entry);
    //       if (rootAlias !== root) SUBS.get(rootAlias).push(entry);

    //       listeners.push({ type: 'signal', root, handler: dec });
    //       if (rootAlias !== root) listeners.push({ type: 'signal', root: rootAlias, handler: dec });
    //       if (!trig.mods?.notimmediate) dec(undefined, trig.name);
    //       continue;
    //     }

    //     // Event triggers
    //     // Resolve target element: explicit id (`#id`) or current element
    //     let targetEl = null;
    //     let eventName = trig.eventName || null;

    //     // Case: explicit element id — no legacy mappings, require real element id
    //     if (trig.elemId) {
    //       targetEl = getElById(trig.elemId, attr);
    //       if (!targetEl) { console.error('[dmax] Error: Element not found for id:', trig.elemId); }
    //     }

    //     // Case: new syntax uses `.window` or `.interval` as eventName while isCurr is true
    //     // Handle special triggers produced by the `_` token: @_window, @_document, @_form, @_interval, @_delay
    //     if (trig.type === 'special') {
    //       const name = trig.name;
    //       if (name === 'window') {
    //         const ev = (trig.arg && String(trig.arg)) || 'resize';
    //         window.addEventListener(ev, handler);
    //         listeners.push({ type: 'event', targetEl: window, eventName: ev, handler });
    //         if (trig.mods?.immediate) handler();
    //         continue;
    //       }
    //       if (name === 'document') {
    //         const ev = (trig.arg && String(trig.arg)) || 'visibilitychange';
    //         document.addEventListener(ev, handler);
    //         listeners.push({ type: 'event', targetEl: document, eventName: ev, handler });
    //         if (trig.mods?.immediate) handler();
    //         continue;
    //       }
    //       if (name === 'interval') {
    //         const ms = parseInt(trig.arg) || 1000;
    //         const tick = () => {
    //           try { handler(new CustomEvent('interval', { detail: { ms } })); } catch (e) { }
    //         };
    //         const id = setInterval(tick, ms);
    //         listeners.push({ type: 'interval', id });
    //         if (trig.mods?.immediate) tick();
    //         continue;
    //       }
    //       if (name === 'delay') {
    //         const ms = parseInt(trig.arg) || 0;
    //         const id = setTimeout(() => {
    //           try { handler(new CustomEvent('delay', { detail: { ms } })); } catch (e) { }
    //         }, ms);
    //         listeners.push({ type: 'timeout', id });
    //         continue;
    //       }
    //       if (name === 'form') {
    //         // bind to closest form ancestor
    //         const formEl = el && el.closest ? el.closest('form') : null;
    //         if (formEl) {
    //           const ev = (trig.arg && String(trig.arg)) || 'submit';
    //           formEl.addEventListener(ev, handler);
    //           listeners.push({ type: 'event', targetEl: formEl, eventName: ev, handler });
    //           if (trig.mods?.immediate) handler();
    //         }
    //         continue;
    //       }
    //     }

    //     // If still no targetEl, fall back to current element
    //     if (!targetEl) targetEl = el;
    //     // Determine final event name
    //     const finalEvent = eventName || getAutoEvent(targetEl);
    //     if (targetEl === null) { console.error('[dmax] Error: Element not found:', trig.elemId); continue; }
    //     // decorate handler with modifiers
    //     const dec = (function (orig, tt) {
    //       const decorated = makeDecorated(orig, tt);
    //       decorated.remove = () => { try { targetEl.removeEventListener(finalEvent, decorated); } catch (e) { } };
    //       return decorated;
    //     })(handler, trig);
    //     targetEl.addEventListener(finalEvent, dec);
    //     listeners.push({ type: 'event', targetEl, eventName: finalEvent, handler: dec });
    //     if (trig.mods?.immediate) dec();
    //   }
    //   if (trigs.length === 0) handler();
    // }
  </script>
</body>

</html>