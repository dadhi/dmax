<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <title>dmax notebook asserts — index-dev.html</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    html,
    body {
      height: 100%;
      margin: 0;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
    }

    header {
      padding: 8px 12px;
      background: #0f172a;
      color: #e2e8f0;
      display: flex;
      align-items: center;
      gap: 12px;
      position: sticky;
      top: 0;
      z-index: 1000;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    #summary {
      margin-left: auto;
      font-weight: 600;
    }

    main {
      display: grid;
      grid-template-rows: auto 1fr;
      height: calc(100% - 0px);
    }

    #out {
      padding: 12px;
      white-space: pre-wrap;
      word-break: break-word;
      margin: 0;
    }

    .note {
      color: #475569;
      font-style: italic;
      padding: 8px 12px;
      border-bottom: 1px solid #e2e8f0;
      background: #f8fafc;
    }

    .chk.pass {
      color: #16a34a;
    }

    .chk.fail {
      color: #dc2626;
    }
  </style>
</head>

<body>
  <header>
    <div id="summary">Tests 0: Failed 0, Total 0</div>
  </header>
  <main>
    <div class="note">Output is mirrored from console.log/error</div>
    <pre id="out"></pre>
    <div id='foo' style="visibility:hidden" ?>good</div>
  </main>
  <script>
    // Mirror console to <pre>, count tests
    (function () {
      const out = document.getElementById('out');
      const summary = document.getElementById('summary');
      let pass = 0, fail = 0, total = 0;
      const orig = { log: console.log, error: console.error, warn: console.warn };
      function toText(v) {
        try {
          if (typeof v === 'string') return v;
          if (v && typeof v === 'object') return JSON.stringify(v);
          return String(v);
        } catch (_) { return String(v); }
      }
      function append(args) {
        const isPass = args && args.length && (args[0] === '✓' || args[0] === '\u2713');
        const isFail = args && args.length && (args[0] === '✗');
        const line = args.map(toText).join(' ');
        const div = document.createElement('div');
        if (isPass || isFail) {
          const chk = document.createElement('span');
          chk.textContent = args[0];
          chk.className = 'chk ' + (isPass ? 'pass' : 'fail');
          div.appendChild(chk);
          const rest = args.slice(1).map(toText).join(' ');
          div.appendChild(document.createTextNode(' ' + rest));
        } else {
          div.textContent = line;
        }
        out.appendChild(div);
        if (isPass) { pass++; total++; }
        else if (isFail) { fail++; total++; }
        summary.textContent = `Tests ${total}: Passed ${pass}, Failed ${fail}`;
      }
      console.log = (...args) => { try { append(args); } finally { orig.log.apply(console, args); } };
      console.error = (...args) => { try { append(args); } finally { orig.error.apply(console, args); } };
      console.warn = (...args) => { try { append(args); } finally { orig.warn.apply(console, args); } };
    })();
  </script>
  <script>
    // @js-check
    //-------------test code-------------------
    stableStringify = (val) => {
      if (Array.isArray(val)) return `[${val.map(stableStringify).join(',')}]`;
      if (val && typeof val === 'object' && !(val instanceof Date)) {
        return `{${Object.keys(val).sort().map(key => `${JSON.stringify(key)}:${stableStringify(val[key])}`).join(',')}}`;
      }
      return JSON.stringify(val);
    };
    deepEqual = (a, b) => {
      if (a === b) return true;
      const aObj = a && typeof a === 'object';
      const bObj = b && typeof b === 'object';
      if (!aObj && !bObj) return Object.is(a, b);
      return stableStringify(a) === stableStringify(b);
    };
    fmt = (val) => (typeof val === 'string' ? `'${val}'` : stableStringify(val));
    assert = (fn, args, expected, label) => {
      const fname = fn && fn.name ? fn.name : '(anonymous)';
      const head = label ? `${fname} — ${label}` : fname;
      try {
        const actual = Array.isArray(args) ? fn(...args) : fn(args);
        const pass = deepEqual(actual, expected);
        if (pass)
          console.log('✓', head, '>>>', fmt(actual));
        else
          console.error('✗', head, '>>> expected:', fmt(expected), 'actual:', fmt(actual));
      } catch (err) {
        console.error('✗', head, '>>> threw:', fmt(err), '>>> expected:', fmt(expected));
      }
    };

    //------- lib code starts here-------------
    // Returns the index of the first found char (from chars) in the s, or -1 if none found,
    // then you can check s[returnedIndex] to see which char it is.
    function indexFirst(s, chars, pos = 0) {
      let i, first = s.length
      for (let c of chars) if ((i = s.indexOf(c, pos)) != -1 && i < first) first = i
      return first === s.length ? -1 : first
    }

    assert(indexFirst, ['abcdefg', ['x', 'y', 'z']], -1, 'none found');
    assert(indexFirst, ['abcdefg', ['x', 'c', 'z']], 2, 'one found');
    assert(indexFirst, ['abcdefgabc', ['a', 'b', 'c'], 3], 7, 'multiple found with pos');
    assert(indexFirst, ['abcdefg', ['a'], 10], -1, 'pos out of range');

    const CAMEL_NAMES = new Map()
    function kebabToCamel(s) {
      if (!s) return s
      let p = s.indexOf('-')
      if (p < 0) return s
      let res = CAMEL_NAMES.get(s)
      if (res) return res
      res = s.slice(0, p)
      while (p >= 0 && ++p < s.length) {
        if (s[p] == '-') continue;
        res += s[p].toUpperCase()
        if (++p < s.length)
          res += s.slice(p, (p = s.indexOf('-', p)) == -1 ? s.length : p)
      }
      CAMEL_NAMES.set(s, res)
      return res
    }

    assert(kebabToCamel, ['foo-bar'], 'fooBar', 'basic case');
    assert(kebabToCamel, ['-bar'], 'Bar', 'lead single');
    assert(kebabToCamel, ['bar-'], 'bar', 'trail single');
    assert(kebabToCamel, ['multi-part-key'], 'multiPartKey', 'multi part');
    assert(kebabToCamel, ['-'], '', 'single dash');
    assert(kebabToCamel, ['--'], '', 'multi dashes only');
    assert(kebabToCamel, ['--leading--dashes'], 'LeadingDashes', 'leading dashes');
    assert(kebabToCamel, ['trailing--dashes-'], 'trailingDashes', 'trailing dashes');

    const DOT = '.'
    const NAME_DELIMS = [DOT] //'[', ']' // @wip parse brackets later
    const SIGN = 's', PROP = DOT, ID = '#', SPEC = '_', NOT = '!', EV = '~' // @wip add support for EV 

    const WIN = '_window'; DOC = '_document'; FRM = '_form'; INTR = '_interval'; TIMT = '_timeout'
    const SPECIALS = [WIN, DOC, FRM, INTR, TIMT]

    function isSpecial(n) {
      if (n.startsWith(SPEC)) for (const s of SPECIALS) { if (n.startsWith(s, 1)) return true }
      return false
    }

    function isPropOrEvent(n) {
      return n.startsWith(ID) || n.startsWith(DOT) || isSpecial(n)
    }

    // @WIP: Phase 1
    // data-dump@foo-bar-signal+#tpl-id instead of data-dump@foo-bar-signal#tpl-id
    // data-class+zebra-even+!zebra-odd instead of data-class:+zebra-even:~zebra-odd
    // ^ instead of __ for mods: data-get^no-cache:posts^replace+user.name^query.username instead of data-get__no-cache:posts__replace+user.name__query.username
    // @WIP: Phase 2
    // data-sign instead of data-def, data-sub, data-sync
    // data-sign:foo:bar='console.log('side effect!'); return 42'
    // data-sign:target@source-signal@.source-prop
    // data-sign:targ@#some.prop@~click // click sets the targ to ev.detail by default or you can data-sign:targ@#some.prop@~click.target.name
    // data-sign:targ@#some.prop@~click='pr ? pr : ev?.target.name ?? null' where pr is additional parameter we are passing to (dm, el, sg, ev, pr) => '...'
    const MOD = '^', TARG = ':', TRIG = '@', STAT = '?', ADD = '+'
    const ALL = [MOD, TARG, TRIG, STAT, ADD]
    const MODS = [MOD]
    const KIND = [MOD, SIGN, PROP, EV, ID, SPEC]

    // Returns {kind:KIND, not:null|bool, root:null|name, path:null|[...names] } or null for invalid item
    function parseItem(aName, type, n, pos = 0) {
      if (!n) return null

      let p = pos
      while (n.startsWith(NOT, p)) ++p
      let not = p == 0 ? null : p % 2 != 0

      let d = n.indexOf(DOT, p)
      let root = d < 0 ? (p == 0 ? n : n.slice(p)) : n.slice(p, d)
      if (root) root = kebabToCamel(root)

      if (type === MOD) {
        if (!root) { console.error('[dmax] Error: Mod name should not be empty for:', n, 'in:', aName); return null }
        if (d < 0 || d + 1 >= n.length) return { kind: MOD, not, root, path: null } // accepts trailing dot in ^mod-foo.
        let val = n.indexOf(DOT, p = d + 1) < 0 ? kebabToCamel(n.slice(p)) : parseItem(aName, TRIG, n, p) // recurse for mod val being a signal
        return { kind: MOD, root, not, path: val }
      }

      let kind = SIGN
      if (root && root.length > 0 && (root[0] === ID || isSpecial(root))) {
        kind = root[0] // ID or SPEC
        root = root.slice(1)
        if (!root) { console.error('[dmax] Error: The', kind, 'element should have a non empty name:', n, 'in:', aName); return null }
      }

      if (d < 0) {
        if (!root && kind === SIGN) { console.error('[dmax] Error: Signal should have a non empty name:', n, 'in:', aName); return null }
        return { kind, not, root, path: null }
      }

      if (!root) kind = PROP
      if (d + 1 == n.length) return { kind, not, root, path: null }

      p = d + 1
      let path = []
      while (p >= 0 && p < n.length) {
        d = n.indexOf(DOT, p)
        const part = n.slice(p, p = d < 0 ? n.length : d)
        if (!part) { console.error('[dmax] Error: Path should not have an empty part:', n, 'in:', aName); return null }
        path.push(kebabToCamel(part))
        ++p
      }
      return { kind, not, root, path }
    }

    assert(parseItem, ['XXX', TRIG, '#hey.foo.bar-baz'], { "kind": "#", "not": null, "path": ["foo", "barBaz"], "root": "hey" }, 'trigger #id.prop.prop')
    assert(parseItem, ['XXX', TARG, 'foo-bar'], { "kind": "s", "not": null, "path": null, "root": "fooBar" }, 'target kebab to camel');
    assert(parseItem, ['XXX', TRIG, '#el.some.prop'], { "kind": "#", "not": null, "path": ["some", "prop"], "root": "el" }, 'trigger id and path');
    assert(parseItem, ['XXX', TRIG, '!foo'], { "kind": "s", "not": true, "path": null, "root": "foo" }, 'negated once');
    assert(parseItem, ['XXX', TRIG, '!!foo'], { "kind": "s", "not": false, "path": null, "root": "foo" }, 'double negation even');
    assert(parseItem, ['XXX', TARG, 'foo.'], { "kind": "s", "not": null, "path": null, "root": "foo" }, 'trailing dot yields null path');
    assert(parseItem, ['XXX', TARG, 'a..b'], null, 'error: empty middle segment');
    assert(parseItem, ['XXX', TARG, 'foo.bar-baz.qux-quux'], { "kind": "s", "not": null, "path": ["barBaz", "quxQuux"], "root": "foo" }, 'path segments kebab->camel');
    assert(parseItem, ['XXX', MOD, '!eq.3'], { "kind": "^", "not": true, "path": "3", "root": "eq" }, 'mod with negation and numeric path');
    assert(parseItem, ['XXX', MOD, '!eq.'], { "kind": "^", "not": true, "path": null, "root": "eq" }, 'mod with negation and dot at the end permitted');
    assert(parseItem, ['XXX', TARG, ''], null, 'error: empty name returns nulls');
    assert(parseItem, ['YYY', TARG, '.'], { "kind": ".", "not": null, "path": null, "root": "" }, 'error: empty name returns nulls');

    function parse(aName, p = 'data-'.length, it = ALL) {
      let items = {}, modItems = null
      while (p >= 0 && p < aName.length) {
        if ((p = indexFirst(aName, it, p)) == -1) { p = aName.length; break }
        let t = aName[p], item = null
        if (++p < aName.length) {
          let end = indexFirst(aName, ALL, p)
          let name = aName.slice(p, p = end != -1 ? end : aName.length)
          if (name) item = parseItem(aName, t, name)
        }

        if (!item) continue // skip null/errors, avoid later null checks

        let ts = items[t] ??= []
        if (t == MOD) {
          ts.push(item);
          if (p >= aName.length || (it === MODS && aName[p] != MOD)) return [items, p]
        } else if (p >= aName.length || aName[p] != MOD) {
          item.mods = items[MOD] ?? null // set to glob mods if any
          ts.push(item);
        } else {
          [modItems, p] = parse(aName, p, MODS)
          let mods = modItems?.[MOD] ?? null
          if (items[MOD]) { // put glob mods if any into local mods but don't override
            if (!mods) mods = items[MOD]
            else {
              let modCount = mods.length
              for (const gm of items[MOD]) {
                let skipGlobal = false
                for (let i = 0; i < modCount; ++i)
                  if (mods[i].root === gm.root) { skipGlobal = true; break }
                if (!skipGlobal) mods.push(gm)
              }
            }
          }
          item.mods = mods
          ts.push(item)
        }
      }

      if (p < aName.length) console.warn('[dmax] Warning: Not everything is parsed "', aName.slice(p), '" in', aName)
      return [items, p]
    }

    assert(parse, ['data-def'], [{}, 8], 'empty')
    assert(parse, ['data-sub:'], [{}, 9], 'single empty')
    assert(parse, ['data-sub^mod'], [{ "^": [{ "kind": "^", "not": null, "path": null, "root": "mod" }] }, 12], 'global mod')
    assert(parse, ['data-sub^mod.some-foo.value^!eq.3'], [{ "^": [{ "kind": "^", "not": null, "path": { "kind": "s", "not": false, "path": ["value"], "root": "someFoo" }, "root": "mod" }, { "kind": "^", "not": true, "path": "3", "root": "eq" }] }, 33], '2 global mods')
    assert(parse, ['data-sub^mod^@hey^foo:bar'], [{ ":": [{ "kind": "s", "mods": [{ "kind": "^", "not": null, "path": null, "root": "mod" }], "not": null, "path": null, "root": "bar" }], "@": [{ "kind": "s", "mods": [{ "kind": "^", "not": null, "path": null, "root": "foo" }, { "kind": "^", "not": null, "path": null, "root": "mod" }], "not": null, "path": null, "root": "hey" }], "^": [{ "kind": "^", "not": null, "path": null, "root": "mod" }] }, 25], '2 global mods and item with mod with item')
    assert(parse, ['data-sub@!xxx@!'], [{ "@": [{ "kind": "s", "mods": null, "not": true, "path": null, "root": "xxx" }] }, 15], 'not name and not empty')
    assert(parse, ['data-sub:xxx:'], [{ ":": [{ "kind": "s", "mods": null, "not": null, "path": null, "root": "xxx" }] }, 13], 'single name')
    assert(parse, ['data-sub::'], [{}, 10], '2 empties')
    assert(parse, ['data-sub:foo^'], [{ ":": [{ "kind": "s", "mods": null, "not": null, "path": null, "root": "foo" }] }, 13], 'name+empty mod')
    assert(parse, ['data-sub:foo^^'], [{ ":": [{ "kind": "s", "mods": null, "not": null, "path": null, "root": "foo" }] }, 14], 'name+2 empty mods')
    assert(parse, ['data-sub:foo-bar^bax.3'], [{ ":": [{ "kind": "s", "mods": [{ "kind": "^", "not": null, "path": "3", "root": "bax" }], "not": null, "path": null, "root": "fooBar" }] }, 22], 'item^mod')
    assert(parse, ['data-sub:foo-bar^bax.3@!something^nice'], [{ ":": [{ "kind": "s", "mods": [{ "kind": "^", "not": null, "path": "3", "root": "bax" }], "not": null, "path": null, "root": "fooBar" }], "@": [{ "kind": "s", "mods": [{ "kind": "^", "not": null, "path": null, "root": "nice" }], "not": true, "path": null, "root": "something" }] }, 38], 'item^mod@item2^mod')
    assert(parse, ['data-sub^ge.2^le.5@foo^le.4'], [{ "@": [{ "kind": "s", "mods": [{ "kind": "^", "not": null, "path": "4", "root": "le" }, { "kind": "^", "not": null, "path": "2", "root": "ge" }], "not": null, "path": null, "root": "foo" }], "^": [{ "kind": "^", "not": null, "path": "2", "root": "ge" }, { "kind": "^", "not": null, "path": "5", "root": "le" }] }, 27], 'combine/do not override global mods into the item')
    assert(parse, ['data-sub^hey@foo:bar+bax'], [{ "+": [{ "kind": "s", "mods": [{ "kind": "^", "not": null, "path": null, "root": "hey" }], "not": null, "path": null, "root": "bax" }], ":": [{ "kind": "s", "mods": [{ "kind": "^", "not": null, "path": null, "root": "hey" }], "not": null, "path": null, "root": "bar" }], "@": [{ "kind": "s", "mods": [{ "kind": "^", "not": null, "path": null, "root": "hey" }], "not": null, "path": null, "root": "foo" }], "^": [{ "kind": "^", "not": null, "path": null, "root": "hey" }] }, 24], 'push all global mods to items')

    function isObjEmpty(o) {
      for (const _ in o) return false
      return true
    }

    const RETURN_THEN = [' ', '(', '{', ';', '[', '"', '\'', '\n', '\r', '\t']
    const SIGN_ARGS = ['dm', 'el']
    const TRIG_ARGS = ['dm', 'el', 'ev', 'sg', 'detail']

    function compileFn(aVal, aName, args) {
      let val = '' + aVal
      var r = val.indexOf('return')
      let body = r != -1 && (r + 6 >= val.length || indexFirst(val, RETURN_THEN, r + 6) == r + 6) ? val : `return(${val})`
      body = `try{ ${body} }catch(e){ console.error('[dmax] Error: eval ${aName} value as function:', e.message, '>>>', ${val}); return }`
      let fn;
      try { fn = Function(...args, body) }
      catch (e) { console.error(`Error compiling ${aName} value to function:`, e.message, '>>>', val); return }
      return fn;
    }

    const _dm = new Map()
    const DM = new Proxy({}, {
      get: (_, key) => _dm.get(key),
      set: (_, key, val) => { _dm.set(key, val); return true; },
      has: (_, key) => _dm.has(key),
      ownKeys: () => Array.from(_dm.keys()),
      getOwnPropertyDescriptor: (_, key) =>
        _dm.has(key) ? { value: _dm.get(key), enumerable: true, configurable: true } : undefined
    });

    // - data-def='{foo: {bar: "hey"}, baz: 1}' // top level fields to signals
    // - data-def:foo='{bar: "hey"}' // foo signal
    // - data-def:foo:baz='`js expr ${42}`' // eval expr as Function body and set to all signals
    // - data-def:foo='el.Value * dm.bar' // you may use other signals and element props
    function dSign(el, aName, aVal) {
      let [it, _p] = parse(aName)
      let tars = it[TARG]
      delete it[TARG]
      if (!isObjEmpty(it)) console.warn('[dmax] Warning: Supports only targets but found more:', aName)
      let val = aVal ? compileFn(aVal, aName, SIGN_ARGS)(DM, el) : null
      if (tars) {
        for (const t of tars) {
          if (t.kind != SIGN) { console.error('[dmax] Error: Only signal targets are supported but found:', t, 'in', aName); continue }
          if (t.mods) console.warn('[dmax] Warning: Mods are not supported:', mods, 'in', aName);
          _dm.set(t.root, val)
        }
      } else if (val && typeof val === 'object') {
        for (const t in val)
          _dm.set(kebabToCamel(t), val[t])
      } else {
        console.error('[dmax] Error: Attribute', aName, 'value should contain object with signal fields, but found', aVal)
      }
    }

    const _sign = (nam, val) => { _dm.clear(); dSign(null, nam, val); return DM };
    const _signEl = (el, nam, val) => { _dm.clear(); dSign(el, nam, val); return DM };
    const _signDmSet = (k, v, nam, val) => { _dm.clear(); DM[k] = v; dSign(null, nam, val); return DM };
    assert(_sign, ['data-def', '{foo: {bar: "hey"}, baz: 1}'], { "baz": 1, "foo": { "bar": "hey" } }, '2 value signals')
    assert(_sign, ['data-def:foo', '{bar: "hey"}'], { "foo": { "bar": "hey" } }, 'signal = value')
    assert(_sign, ['data-def:foo-bar:baz'], { "baz": null, "fooBar": null }, 'signals')
    assert(_sign, ['data-def:foo-bar:baz', '`Mamma Mia ${42}`'], { "baz": "Mamma Mia 42", "fooBar": "Mamma Mia 42" }, 'bonkers')

    assert(_signEl, [{ "name": "John" }, 'data-def:foo', '"Hey, " + el.name'], { "foo": "Hey, John" }, 'using el')
    assert(_signDmSet, ['name', 'Noize', 'data-def:greet', '"Hey, " + dm.name'], { "name": "Noize", "greet": `Hey, Noize` }, 'using dm')

    function getElById(id, aName) {
      if (!id) return null
      const el = document.getElementById(id)
      if (!el) console.error(`[dmax] Error: element #${id} from ${aName} is not found`)
      return el;
    };

    const _getElById = (id, aName) => getElById(id, aName)?.textContent ?? null;

    assert(_getElById, ['foo', 'data-sub:#foo@bar'], 'good', 'get existing elem')

    function getAutoProp(el) {
      if (!el) return 'textContent'
      const t = el.type, n = el.tagName
      return t === 'checkbox' || t === 'radio' ? 'checked'
        : n === 'INPUT' || n === 'SELECT' || n === 'TEXTAREA' ? 'value'
          : 'textContent'
    }

    // Default event for element (tags are upper-case per W3C; no toUpperCase needed)
    function getAutoEvent(el) {
      if (!el) return 'click'
      let n = el.tagName
      return n === 'FORM' ? 'submit'
        : n === 'INPUT' || n === 'SELECT' || n === 'TEXTAREA' ? 'change'
          : 'input'
    }

    function isNil(v) { return v === null || v === undefined }

    function getNestedVal(obj, path, depth = 0) {
      let v = obj
      if (isNil(v) || !path) return [v, 0]
      let n = !depth || depth > path.length ? path.length : depth
      for (let i = 0; i < n; ++i) if (isNil(v = v[path[i]])) return [v, i + 1]
      return [v, n]
    }

    assert(getNestedVal, [getElById('foo', 'xxx'), ['textContent']], ['good', 1], 'getNestedVal depth 1')
    assert(getNestedVal, [{ foo: { bar: { baz: 42 } } }, ['foo', 'bar', 'baz']], [42, 3], 'getNestedVal 42')
    assert(getNestedVal, [{ foo: { bar: null } }, ['foo', 'bar', 'baz']], [null, 2], 'getNestedVal 42')

    function setProp(el, aName, tar, val) {
      if (tar.kind != ID && tar.kind != PROP) { console.error('[dmax] Error: Unsupported target kind for setting the property', tar, 'in', aName); return }
      let obj = tar.kind == ID ? getElById(tar.root, aName) : el
      let path = tar.path, prop = null
      if (!path)
        prop = getAutoProp(el);
      else if (path.length > 0) {
        [obj, _] = getNestedVal(obj, path, path.length - 1)
        prop = path.at(-1)
      }
      if (!obj || !prop) { console.error('[dmax] Error setting non existing property for: ', tar, 'in', aName); return }
      try {
        if (obj[prop] !== val) obj[prop] = val; // @wip deep comparison???
      } catch (e) {
        console.error('[dmax] Error: Failed to set property:', e.message, '>>>', tar, 'on', el);
      }
    }

    const SHAPE = 'shape', CONTENT = 'content'
    const _subs = new Map()

    function emitSignal(root, changeMode = CONTENT, shapeChange = null) {
      const handlers = _subs.get(root);
      if (handlers) {
        for (const h of handlers) {
          try {
            // @wip what and why do we need this??
            // Legacy function handlers (fast path) for content and shape
            if (typeof h === 'function') {
              h(undefined, sg);
              continue;
            }
            if (!(h && typeof h.fn === 'function')) continue;

            if (changeMode === CONTENT) {
              if (h.mode === CONTENT && !h.childPath) h.fn(undefined, sg)
              continue;
            }

            if (shapeChange && h.childPath) {
              let matches =
                shapeChange.added && shapeChange.added.indexOf(h.childPath) != 1 ||
                shapeChange.removed && shapeChange.removed.indexOf(h.childPath) != 1;
              if (!matches) continue;
            }

            h.fn(undefined, sg, detail = shapeChange);
          } catch (e) { console.error('[dmax] Error: Subscriber handler error', e); }
        }
      }
      // updateDebug(); // @wip
    }

    function diffValues(before, after) {
      const out = { added: [], removed: [] };
      if (before == null && after == null) return out;
      if (Array.isArray(before) || Array.isArray(after)) {
        const a = Array.isArray(before) ? before : [];
        const b = Array.isArray(after) ? after : [];
        if (b.length > a.length) {
          for (let i = a.length; i < b.length; i++) { out.added.push(i); }
        } else if (b.length < a.length) {
          for (let i = b.length; i < a.length; i++) { out.removed.push(i); }
        }
        // value changes within existing indices are considered content (not shape) and are not reported here
        return out;
      }
      // objects
      const bb = before && typeof before === 'object' ? before : {};
      const aa = after && typeof after === 'object' ? after : {};
      for (const k in aa) { if (!(k in bb)) { out.added.push(k); } }
      for (const k in bb) { if (!(k in aa)) { out.removed.push(k); } }
      // property value changes are considered content-only and are not included in shape diffs
      return out;
    }

    // If sg not exist in the _dm, then we will create it -> create missing target on demand
    function setSignalVal(el, aName, tar, val, ev) {
      const root = tar.root, path = tar.path, isValObj = val && typeof val == 'object'
      const sgRoot = _dm.get(root)
      if (!path) { // at depth 0
        if (sgRoot === val) return // @wip deep compare?
        _dm.set(root) = val
        emitSignal(root, isValObj ? SHAPE : CONTENT, null) // setting x = { foo: [], bar:{} } is the shape change
        return
      }

      if (!sgRoot) { console.error('[dmax] Error: cannot set value to absent signal root:', root, 'at path:', path); return }

      let depth = path.length
      let [sgObj, d] = getNestedVal(sgRoot, path, depth - 1)
      if (!sgObj) { console.error('[dmax] Error: cannot set value to missing signal object at:', root, 'at path:', path, 'at index:', d - 1); return }

      const curr = sgObj[path.at(-1)]
      if (curr === val) return; // @wip deep compare?

      changeMode = curr === undefined ? SHAPE : CONTENT

      // @wip NEXT
      // prepare change info for shape mutations
      let changeInfo = null;
      if (path.length === 1) {
        const before = _dm.get(root);
        _dm.set(root, val);
        try { const alias = sigKey(root); if (alias !== root) _dm.set(alias, val); } catch (e) { }
        if (changeMode === 'shape')
          changeInfo = diffValues(before, val)
      } else {
        // structural shallow clone: only clone root object/array and walk path
        const orig = _dm.get(root);
        // compute parent path and before-parent snapshot
        const parentPath = path.slice(0, -1).join('.');
        const beforeParent = getSignalVal(parentPath);
        let base;
        try { base = Array.isArray(orig) ? orig.slice() : (orig && typeof orig === 'object' ? Object.assign({}, orig) : (typeof orig === 'object' ? {} : {})); } catch (e) { base = {} }
        let t = base;
        for (let i = 1; i < path.length - 1; i++) {
          const key = toCamel(path[i]);
          if (typeof t[key] !== 'object' || t[key] === null) t[key] = {};
          // shallow clone child to avoid mutating original reference
          const child = t[key];
          t[key] = Array.isArray(child) ? child.slice() : Object.assign({}, child);
          t = t[key];
        }
        t[toCamel(path[path.length - 1])] = val;
        // after-parent snapshot
        const afterParent = (function () {
          let node = base;
          for (let i = 1; i < path.length - 1; i++) node = node[toCamel(path[i])] || {};
          return node;
        })();
        _dm.set(root, base);
        try { const alias = sigKey(root); if (alias !== root) _dm.set(alias, base); } catch (e) { }
        if (changeMode === 'shape')
          changeInfo = diffValues(beforeParent, afterParent)
      }
      emitSignal(tar, changeMode, changeInfo);
    }

    let syncDepth = 0, MAX_SYNC_DEPTH = 16;
    function setSignal(el, aName, tar, val, ev) {
      if (syncDepth++ > MAX_SYNC_DEPTH) {
        console.error(`[dmax] Error: Infinite loop detected for signal: ${tar} (depth > ${MAX_SYNC_DEPTH}) in ${aName}`)
        return
      }
      try { return setSignalVal(el, aName, tar, val, ev) } finally { syncDepth-- }
    }

    // // Track all event listeners and signal handlers for cleanup
    // cleanupMap = new WeakMap();

    // function dSub(el, aName, aVal) {
    //   let [it, _p] = parse(aName)
    //   let tars = it[TARG]
    //   let trigs = it[TRIG]
    //   let globMods = it[MOD]
    //   delete it[TARG]; delete it[TRIG]; delete it[MOD];
    //   if (!isObjEmpty(it)) console.warn('[dmax] Warning: Supports only targets, triggers, mods but found more:', aName)
    //   if (!aVal) { console.error('[dmax] Error: in ', aName, 'it requires a value but found none', aVal); return }
    //   let fn = compileFn(aVal, aName, TRIG_ARGS)
    //   if (!fn) return

    //   let setters = []
    //   for (const tar of tars) {
    //     if (!tar || !tar.kind) continue
    //     let setter = tar.kind == SIGN
    //       ? (t, val, ev) => setSignal(el, aName, t, val, ev)
    //       : (t, val, _ev) => setProp(el, aName, t, val)
    //     setters.push(setter)
    //   }

    //   const handler = (ev, sg, detailArg) => {
    //     const detail = ev && ev.detail && ev.detail.change ? ev.detail.change : detailArg;
    //     const val = fn(DM, el, ev, sg, detail);
    //     if (!appliers || appliers.length === 0) return;
    //     try {
    //       for (const ap of appliers) if (ap) ap(val, ev);
    //     } catch (e) { console.error('[dmax] Error: Applier error', e); }
    //   };

    //   // Track listeners for cleanup
    //   let listeners = cleanupMap.get(el);
    //   if (!listeners) cleanupMap.set(el, listeners = []);
    //   for (let trig of trigs) {

    //     // build a decorated handler that supports modifier semantics: __prevent, __once, __debounce, __throttle, __and
    //     const makeDecorated = (hand, t) => {
    //       const { mods = {} } = t;
    //       const debMs = mods.debounce == null ? null : +mods.debounce;
    //       const thrMs = mods.throttle == null ? null : +mods.throttle;
    //       const once = 'once' in mods;
    //       const prevent = 'prevent' in mods;
    //       const andPath = mods.and ?? null;
    //       const guardEq = 'eq' in mods ? mods.eq : undefined;
    //       const guardNe = 'ne' in mods ? mods.ne : undefined;
    //       const guardGt = 'gt' in mods ? +mods.gt : undefined;
    //       const guardGe = 'ge' in mods ? +mods.ge : undefined;
    //       const guardLt = 'lt' in mods ? +mods.lt : undefined;
    //       const guardLe = 'le' in mods ? +mods.le : undefined;
    //       let timer = null;
    //       let last = 0;
    //       const decorated = function (ev, sg, detailArg) {
    //         if (prevent) ev?.preventDefault?.();
    //         const run = () => {
    //           if (andPath && !getSignalVal(String(andPath))) return;
    //           // Get subject value, apply negation if trigger is negated
    //           let subjectVal = t.type === 'signal' ? getSignalVal(String(t.name)) : ev?.detail?.ms;
    //           if (t.negated && t.type === 'signal') subjectVal = !subjectVal;
    //           if (guardEq !== undefined && String(subjectVal) !== String(guardEq)) return;
    //           if (guardNe !== undefined && String(subjectVal) === String(guardNe)) return;
    //           if (guardGt !== undefined && !(+subjectVal > guardGt)) return;
    //           if (guardGe !== undefined && !(+subjectVal >= guardGe)) return;
    //           if (guardLt !== undefined && !(+subjectVal < guardLt)) return;
    //           if (guardLe !== undefined && !(+subjectVal <= guardLe)) return;
    //           try { hand(ev, sg, detailArg); } catch (e) { console.error('[dmax] Error: Handler error', e); }
    //           if (once && decorated && decorated.remove) decorated.remove();
    //         };
    //         if (debMs != null) { clearTimeout(timer); timer = setTimeout(run, debMs); return; }
    //         if (thrMs != null) { const now = Date.now(); if (now - last >= thrMs) { last = now; run(); } return; }
    //         run();
    //       };
    //       return decorated;
    //     };

    //     if (trig.type === 'signal') {
    //       const rootRaw = String(trig.name).split('.')[0];
    //       const rootBase = (rootRaw.indexOf('[') !== -1) ? rootRaw.split('[')[0] : rootRaw;
    //       const root = toCamel(rootBase);
    //       const rootAlias = sigKey(rootBase);
    //       if (!SUBS.has(root)) SUBS.set(root, []);
    //       if (rootAlias !== root && !SUBS.has(rootAlias)) SUBS.set(rootAlias, []);
    //       const dec = makeDecorated(handler, trig);
    //       // allow removal for __once and other removals; handle both legacy function entries and object entries
    //       dec.remove = () => {
    //         const arr = SUBS.get(root) || [];
    //         SUBS.set(root, arr.filter(it => (typeof it === 'function' ? it !== dec : it.fn !== dec)));
    //         if (rootAlias !== root) { const arr2 = SUBS.get(rootAlias) || []; SUBS.set(rootAlias, arr2.filter(it => (typeof it === 'function' ? it !== dec : it.fn !== dec))); }
    //       };
    //       // support __shape modifier: register subscription object with optional childPath
    //       let entry = dec;
    //       if (trig.mods && ('shape' in trig.mods || 'content' in trig.mods)) {
    //         const sval = (trig.mods && 'shape' in trig.mods) ? ((trig.mods.shape === true || trig.mods.shape === 1) ? null : (trig.mods.shape != null ? String(trig.mods.shape) : null)) : null;
    //         entry = { fn: dec, mode: ('shape' in trig.mods ? 'shape' : 'content'), childPath: sval };
    //       }

    //       SUBS.get(root).push(entry);
    //       if (rootAlias !== root) SUBS.get(rootAlias).push(entry);

    //       listeners.push({ type: 'signal', root, handler: dec });
    //       if (rootAlias !== root) listeners.push({ type: 'signal', root: rootAlias, handler: dec });
    //       if (!trig.mods?.notimmediate) dec(undefined, trig.name);
    //       continue;
    //     }

    //     // Event triggers
    //     // Resolve target element: explicit id (`#id`) or current element
    //     let targetEl = null;
    //     let eventName = trig.eventName || null;

    //     // Case: explicit element id — no legacy mappings, require real element id
    //     if (trig.elemId) {
    //       targetEl = getElById(trig.elemId, attr);
    //       if (!targetEl) { console.error('[dmax] Error: Element not found for id:', trig.elemId); }
    //     }

    //     // Case: new syntax uses `.window` or `.interval` as eventName while isCurr is true
    //     // Handle special triggers produced by the `_` token: @_window, @_document, @_form, @_interval, @_delay
    //     if (trig.type === 'special') {
    //       const name = trig.name;
    //       if (name === 'window') {
    //         const ev = (trig.arg && String(trig.arg)) || 'resize';
    //         window.addEventListener(ev, handler);
    //         listeners.push({ type: 'event', targetEl: window, eventName: ev, handler });
    //         if (trig.mods?.immediate) handler();
    //         continue;
    //       }
    //       if (name === 'document') {
    //         const ev = (trig.arg && String(trig.arg)) || 'visibilitychange';
    //         document.addEventListener(ev, handler);
    //         listeners.push({ type: 'event', targetEl: document, eventName: ev, handler });
    //         if (trig.mods?.immediate) handler();
    //         continue;
    //       }
    //       if (name === 'interval') {
    //         const ms = parseInt(trig.arg) || 1000;
    //         const tick = () => {
    //           try { handler(new CustomEvent('interval', { detail: { ms } })); } catch (e) { }
    //         };
    //         const id = setInterval(tick, ms);
    //         listeners.push({ type: 'interval', id });
    //         if (trig.mods?.immediate) tick();
    //         continue;
    //       }
    //       if (name === 'delay') {
    //         const ms = parseInt(trig.arg) || 0;
    //         const id = setTimeout(() => {
    //           try { handler(new CustomEvent('delay', { detail: { ms } })); } catch (e) { }
    //         }, ms);
    //         listeners.push({ type: 'timeout', id });
    //         continue;
    //       }
    //       if (name === 'form') {
    //         // bind to closest form ancestor
    //         const formEl = el && el.closest ? el.closest('form') : null;
    //         if (formEl) {
    //           const ev = (trig.arg && String(trig.arg)) || 'submit';
    //           formEl.addEventListener(ev, handler);
    //           listeners.push({ type: 'event', targetEl: formEl, eventName: ev, handler });
    //           if (trig.mods?.immediate) handler();
    //         }
    //         continue;
    //       }
    //     }

    //     // If still no targetEl, fall back to current element
    //     if (!targetEl) targetEl = el;
    //     // Determine final event name
    //     const finalEvent = eventName || getAutoEvent(targetEl);
    //     if (targetEl === null) { console.error('[dmax] Error: Element not found:', trig.elemId); continue; }
    //     // decorate handler with modifiers
    //     const dec = (function (orig, tt) {
    //       const decorated = makeDecorated(orig, tt);
    //       decorated.remove = () => { try { targetEl.removeEventListener(finalEvent, decorated); } catch (e) { } };
    //       return decorated;
    //     })(handler, trig);
    //     targetEl.addEventListener(finalEvent, dec);
    //     listeners.push({ type: 'event', targetEl, eventName: finalEvent, handler: dec });
    //     if (trig.mods?.immediate) dec();
    //   }
    //   if (trigs.length === 0) handler();
    // }
  </script>
</body>

</html>