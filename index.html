<!doctype html>
<html>
<head>
<meta charset="utf-8"/>
<title>dmax v0.3 MVP Copy</title>

<style>
  .preview{padding:12px;border:2px solid #ddd;margin:8px 0;border-radius:6px;font-weight:bold}
  .active{border-color:#28a745;background:#eaffea}
  .inactive{opacity:.7;filter:grayscale(.2)}
  .zebra-even, .zebraEven{background:#ffffff}
  .zebra-odd, .zebraOdd{background:#f6f6f6}
</style>
</head>
<body>



<div data-def='{
  "user": {
    "name": "Alice",
    "age": 25,
    "ui": {
      "theme-color": "#007bff",
      "is-active": true,
      "font-size": 16
    }
  },
  "count": 10,
  "doubled": 20,
  "posts": ["First post","Second post","Third post"],
  "threads": [
    {"title":"Thread A","replies":["A1","A2"]},
    {"title":"Thread B","replies":["B1"]},
    {"title":"Thread C","replies":[]}
  ],
  "message": "Hello World",
  "postObjs": [{"title":"Post A"},{"title":"Post B"}],
  "idx": 0,
  "once-test": 0,
  "always-test": 0,
  "guard-val": 3,
  "other-flag": false
}'></div>



  <h3>1. Deep Nested Signal Sync</h3>
  <div class="page">data-sync:user.name, data-sync:user.age</div>
  
  <label>User Name (nested path):</label>
  <input type="text" data-sync:user.name>
  <p>Hello, <strong data-sync:user.name></strong>!</p>
  <label>Age:</label>
  <input type="number" data-sync:user.age>
  <p>Age: <span data-sync:user.age></span> years old</p>
</section>

<section>
  <h3>1.a data-sync Direction Examples</h3>
  <div class="page">Demonstrates explicit sync directions: signal->element, element->signal, and two-way.</div>
  <div style="margin:6px 0">
    <label>Signal -> Element (one-way): <input id="sigToProp" data-sync@user.name></label>
  </div>
  <div style="margin:6px 0">
    <label>Element -> Signal (one-way): <input id="elToSig" data-sync:user.name@.></label>
  </div>
  <div style="margin:6px 0">
    <label>Two-way (default): <input id="twoWay" data-sync:user.name></label>
  </div>
  <div style="margin:6px 0">Signal preview: <span data-sub:.@user.name="dm.user.name"></span></div>
</section>


<section id="separate-demo">
  <h3>Separate Live Demo</h3>
  <div class="page">This is a standalone demo area to showcase bracket-index and simple bindings.</div>
  <div style="padding:8px;border:1px solid #ddd;border-radius:6px;margin:8px 0">
    <label>Index (idx): <input id="demoIdx" type="number" min="0" value="0" data-sync:idx></label>
    <div style="margin-top:8px">
      <button id="demoSet0" data-sub:postObjs.0.title@.click="'DemoPost0'">Set Post 0 Title</button>
      <button id="demoSet1" data-sub:postObjs.1.title@.click="'DemoPost1'">Set Post 1 Title</button>
      <button id="demoSetIndirect" data-sub:.@postObjs[idx]="dm.postObjs && dm.postObjs[dm.idx] && dm.postObjs[dm.idx].title">Show current indexed title</button>
    </div>
    <div style="margin-top:8px">Indexed title preview: <strong id="demoIndexedPreview" data-sub:.@postObjs[idx]="(dm.postObjs && dm.postObjs[dm.idx]) ? dm.postObjs[dm.idx].title : ''"></strong></div>
  </div>
</section>

<section>
  <h3>2. Style & Boolean Deep Sync</h3>
  <div class="page">data-sync:user.ui.theme-color, data-sub:.style.color@user.ui.theme-color, data-sync:user.ui.font-size, data-sub:.style.font-size@user.ui.font-size, data-sync:user.ui.is-active, data-sub:.@user.ui.is-active</div>
  
  <label>Theme Color:</label>
  <input type="color" data-sync:user.ui.theme-color>
  <div class="preview" data-sub:.style.color@user.ui.theme-color="dm.user.ui.themeColor">This text color syncs to theme-color signal!</div>
  <label>Font Size: <span data-sync:user.ui.font-size></span>px</label>
  <input type="range" min="12" max="32" data-sync:user.ui.font-size>
  <p data-sub:.style.font-size@user.ui.font-size="`${dm.user.ui.fontSize}px`">This text resizes dynamically!</p>
  <label><input type="checkbox" data-sync:user.ui.is-active> Active Status</label>
  <p>Status: <strong data-sub:.@user.ui.is-active="dm.user.ui.isActive ? 'ðŸŸ¢ ONLINE' : 'ðŸ”´ OFFLINE'"></strong></p>
</section>

<section>
  <h3>3. Multiple Triggers & Targets</h3>
  <div class="page">data-sub:count@.click, data-sub:.@count, data-sub:.:doubled@count</div>
  
  <button data-sub:count@.click="dm.count + 1">+1</button>
  <button data-sub:count@.click="dm.count - 1">-1</button>
  <button data-sub:count@.click="0">Reset</button>
  <p>Count: <strong data-sub:.@count="dm.count"></strong></p>
  <p>Multi-target (updates 3 places): <span data-sub:.:doubled@count="dm.count * 2"></span></p>
  <button id="probeBtn" data-sub:.@.click="el.id + ' ' + ev.type + ' ' + (sg || 'no-sg')">Probe</button>
  <span id="probeOut" data-sub:.@count="sg"></span>

  
  <div style="margin-top:8px">
    <button id="gOnceBtn" data-sub__once:once-test@.click="dm.onceTest + 1">GlobalOnce +1</button>
    <span id="gOnceDisplay" data-sub:.@once-test="dm.onceTest"></span>
    <button id="gAlwaysBtn" data-sub__once:always-test@.click__always="dm.alwaysTest + 1" style="margin-left:8px">GlobalOnce+triggerAlways +1</button>
    <span id="gAlwaysDisplay" data-sub:.@always-test="dm.alwaysTest"></span>
  </div>
  <div style="margin-top:8px;padding:8px;border:1px solid #eee;border-radius:6px">
    <div>Guard examples (eq/ne/gt/ge/lt/le/notand):</div>
      <div style="margin:6px 0">
      <button id="incGuard" data-sub:guard-val@.click="dm.guardVal + 1">Inc Guard</button>
      <span id="guardValDisplay" data-sub:.@guard-val="dm.guardVal" style="margin-left:8px"></span>
    </div>
    <div>
      <span id="gtOut" data-sub:.@guard-val__gt.5="dm.guardVal > 5 ? 'GT5' : ''"></span>
      <span id="eqOut" data-sub:.@guard-val__eq.3="dm.guardVal == 3 ? 'EQ3' : ''" style="margin-left:8px"></span>
      <span id="notandOut" data-sub__notand.other-flag:.@guard-val="dm.guardVal ? 'allowed' : ''" style="margin-left:8px"></span>
    </div>
  </div>

  <div style="margin-top:8px;border:1px dashed #eee;padding:8px;border-radius:6px">
    <div>Interval / Delay exposure (shows `ev.type`, `ev.detail.ms`, and `sg`):</div>
    <div style="margin:6px 0">
      <span id="intervalInfo" data-sub:.@_interval.1000="(ev && ev.type) + ' ' + (ev && ev.detail && ev.detail.ms) + ' sg:' + (sg || 'no-sg')"></span>
      &nbsp; â€” automatic @_interval (every 1s)
    </div>
    <div style="margin:6rem px 0">
      <span id="delayInfoAuto" data-sub:.@_delay.1500="(ev && ev.type) + ' ' + (ev && ev.detail && ev.detail.ms) + ' sg:' + (sg || 'no-sg')"></span>
      &nbsp; â€” automatic @_delay (one-shot 1.5s)
    </div>
    <div style="margin:6px 0">
      <button id="manualDelayBtn" onclick="document.getElementById('manualDelayTarget').dispatchEvent(new CustomEvent('delay',{detail:{ms:700}}))">Trigger manual delay (700ms)</button>
      <span id="manualDelayTarget" data-sub:.@.delay="(ev && ev.type) + ' ' + (ev && ev.detail && ev.detail.ms) + ' el:' + (el && el.id) + ' sg:' + (sg || 'no-sg')" style="margin-left:8px"></span>
    </div>
  </div>
</section>

<section>
  <h3>4. Side Effects & Multiple Triggers</h3>
  <div class="page">data-sub@count@#btn1.click@#btn2.click, data-sub:#@count@#btn1.click@#btn2.click</div>
  
  <button id="btn1">Button 1</button>
  <button id="btn2">Button 2</button>
  <p>Side effect logs: <span data-sub@count@#btn1.click@#btn2.click="console.log('Triggered!', dm.count) || 'âœ“ Check console'"></span></p>
  <p>Multi-trigger display: <strong data-sub:#@count@#btn1.click@#btn2.click="dm.count + ' (updated)'"></strong></p>
</section>

<section>
  <h3>5. Cross-Element Property Sync</h3>
  <div class="page">data-sync:message, data-sub:.@#src.input, data-sub:.value@#src.input</div>
  
  <label>Source Input:</label>
  <input id="src" placeholder="Type here..." data-sync:message>
  <label>Mirror (via data-sub):</label>
  <p class="preview" data-sub:.@#src.input="document.getElementById('src').value"></p>
  <label>Another Mirror:</label>
  <input id="mirror" readonly data-sub:.value@#src.input="document.getElementById('src').value">
</section>

<section>
  <h3>6. Window Events & Intervals</h3>
  <div class="page">data-sub:.@_window.resize, data-sub:.@_interval.1000</div>
  
  <p>Window width: <span data-sub:.@_window.resize="window.innerWidth + 'px'"></span></p>
  <p>Current time: <span data-sub:.@_interval.1000="new Date().toLocaleTimeString()"></span></p>
</section>

<section>
  <h3>7. Default Props & Events</h3>
  <div class="page">data-sub:.@#inp1, data-sub:.@#btn3</div>
  
  <input id="inp1" placeholder="Default event (input)">
  <p>Mirror using @.: <span data-sub:.@#inp1="document.getElementById('inp1').value"></span></p>
  <button id="btn3">Click me</button>
  <p>Default event @.: <span data-sub:.@#btn3="'Clicked!'" ></span></p>
</section>

<section>
  <h3>8. Classes & Display (data-class / data-disp)</h3>
  <div style="margin:6px 0">
    <label><input id="classToggle" type="checkbox" data-sync:user.ui.is-active> Toggle Active</label>
  </div>
  <div id="classBox" data-class:.active.-inactive@user.ui.is-active="dm.user.ui.isActive" style="padding:8px;border:1px solid #ccc;margin:6px 0">Status Box</div>
  <p id="displayBox" data-disp:.@user.ui.is-active="dm.user.ui.isActive">Visible only when active</p>
  <p id="displayNeg" data-disp:.@user.ui.is-active="!dm.user.ui.isActive">Visible only when NOT active (negated)</p>
</section>

<section>
  <h3>9. List Rendering (data-dump)</h3>
  <div class="page">data-dump@posts#tpl-post â€” template as child &lt;template&gt; or reference by id</div>
  
  <template id="tpl-post">
    <li data-index="$index" data-class:.zebra-even.-zebra-odd="$index % 2 === 0">
      <span class="num" data-sub:.@posts="$index + 1"></span>
      <span class="item" data-sub:.@posts="(typeof dm.posts[$index] === 'object') ? JSON.stringify(dm.posts[$index], null, 2) : dm.posts[$index]" style="margin-left:8px"></span>
    </li>
  </template>
  <ul data-dump@posts#tpl-post></ul>

  <h4>Inline-template data-dump example (no #id)</h4>
  <ul id="inline-posts" data-dump@posts>
    <template>
      <li data-index="$index" data-class:.zebra-even.-zebra-odd="$index % 2 === 0">
        <span class="num" data-sub:.@posts="$index + 1"></span>
        <span class="item" data-sub:.@posts="(typeof dm.posts[$index] === 'object') ? JSON.stringify(dm.posts[$index], null, 2) : dm.posts[$index]" style="margin-left:8px"></span>
      </li>
    </template>
  </ul>

  <div style="margin-top:8px">
    <button id="addPost" data-sub:posts@.click="(dm.posts || []).concat(['New post ' + ((dm.posts && dm.posts.length) || 0) ])">Add Post</button>
    <button id="removeFirst" data-sub:posts@.click="(dm.posts || []).slice(1)">Remove First</button>
    <button id="removePost" data-sub:posts@.click="(dm.posts || []).slice(0, Math.max(0, (dm.posts || []).length - 1))">Remove Last</button>
    <button id="updateSecond" data-sub:posts@.click="(function(){ if(!(dm.posts && dm.posts.length>1)) return dm.posts; const p = dm.posts.slice(0); p[1] = (p[1] || '') + ' (updated)'; return p })()">Update 2nd</button>
  </div>

  <h4>Nested data-dump example</h4>
  <template id="tpl-thread">
    <li>Thread: <strong data-$it></strong>
      <div class="replies-placeholder"></div>
    </li>
  </template>
  <ul data-dump@threads#tpl-thread></ul>

  <h4>Nested inline-template example</h4>
  <ul id="inline-threads" data-dump@threads>
    <template>
      <li>Thread: <strong data-$it></strong>
        <div class="replies-placeholder"></div>
      </li>
    </template>
  </ul>
</section>

<section>
  <h3>10. Modifiers demo (once/debounce/throttle/and)</h3>
  <div>
    <button id="onceBtn" data-sub:mod-once@.click__once="(dm.modOnce || 0) + 1">Once</button>
    <span id="onceVal" data-sub:.@mod-once="dm.modOnce"></span>
  </div>
  <div>
    <button id="debBtn" data-sub:mod-deb@.click__debounce.120="(dm.modDeb || 0) + 1">Debounce</button>
    <span id="debVal" data-sub:.@mod-deb="dm.modDeb"></span>
  </div>
  <div>
    <button id="thrBtn" data-sub:mod-thr@.click__throttle.120="(dm.modThr || 0) + 1">Throttle</button>
    <span id="thrVal" data-sub:.@mod-thr="dm.modThr"></span>
  </div>
  <div>
    <label><input id="gate" type="checkbox" data-sync:gate> Gate</label>
    <button id="andBtn" data-sub:mod-and@.click__and.gate="(dm.modAnd || 0) + 1">AND</button>
    <span id="andVal" data-sub:.@mod-and="dm.modAnd"></span>
  </div>
</section>

<h4>State Tree (Live Debug):</h4>
<pre data-debug></pre>

<section>
  <h3>11. Actions demo (JSONPlaceholder)</h3>
  <div>
    <button id="loadPost" data-get:post-result?busy__busy,err__err@.click="https://jsonplaceholder.typicode.com/posts/1">Load post #1 (GET)</button>
    <div style="margin-top:8px">Busy: <span data-sub:.@busy="dm.busy"></span> | Error: <span data-sub:.@err="dm.err"></span></div>
    <pre style="background:#f6f8fa;padding:8px;border-radius:6px;margin-top:8px" data-sub:.@post-result="JSON.stringify(dm.postResult, null, 2)"></pre>
  </div>

  <div style="margin-top:12px">
    <label>New post title:</label>
    <input id="newTitle" placeholder="Title" />
    <label style="margin-left:8px">Author name:</label>
    <input id="newUserName" placeholder="Name" />
    <label style="margin-left:8px">Author email:</label>
    <input id="newUserEmail" placeholder="Email" />
    <button id="createPost" data-post^json+#newTitle.value__body.title+#newUserName.value__body.user.name+#newUserEmail.value__body.user.email:created-post?busy__busy,err__err@.click="https://jsonplaceholder.typicode.com/posts">Create post (POST ^json)</button>
    <pre style="background:#fff8f0;padding:8px;border-radius:6px;margin-top:8px" data-sub:.@created-post="JSON.stringify(dm.createdPost, null, 2)"></pre>
  </div>
</section>



<script>


// dmax MVP logic with new syntax support and modular parsing
(()=>{
  const S=new Map(), subs=new Map(), keyCache=new Map(), fnCache=new Map();
  
  // Phase 2.1: Proxy for dm - eliminates Object.fromEntries allocations
  const dmProxy = new Proxy({}, {
    get: (_, key) => S.get(key),
    set: (_, key, val) => { set(key, val); return true; },
    has: (_, key) => S.has(key),
    ownKeys: () => Array.from(S.keys()),
    getOwnPropertyDescriptor: (_, key) => 
      S.has(key) ? { value: S.get(key), enumerable: true, configurable: true } : undefined
  });
  
  // Common character-code constants used by parsers
  const CC = { DOT: 46, COLON: 58, AT: 64, UNDERSCORE: 95, HASH: 35 };
  const debug=document.querySelector('[data-debug]');

  // Optimized kebabâ†’camel (no regex, cached)
  const toCamel = s => {
    if(!s || s.indexOf('-') === -1) return s;
    if(keyCache.has(s)) return keyCache.get(s);
    let result = '', i = 0;
    while(i < s.length){
      if(s[i] === '-'){
        // Skip multiple consecutive hyphens
        while(s[i] === '-' && i + 1 < s.length) i++;
        if(i < s.length) result += s[i].toUpperCase(), i++;
      } else {
        result += s[i++];
      }
    }
    keyCache.set(s, result);
    return result;
  };
  // Canonical signal key used for Map lookups - normalize toCamel and lowercase
  const sigKey = s => {
    if(!s) return s;
    return toCamel(String(s)).toLowerCase();
  };

  // Default property for element (consistent, compact)
  const getAutoProp = el =>
    !el ? 'textContent' :
    (el.type === 'checkbox' || el.type === 'radio') ? 'checked' :
    (el.tagName === 'INPUT' || el.tagName === 'SELECT' || el.tagName === 'TEXTAREA') ? 'value' :
    'textContent';

  // Default event for element (tags are upper-case per W3C; no toUpperCase needed)
  const getAutoEvent = el =>
    !el || !el.tagName ? 'click' :
    (el.tagName === 'FORM') ? 'submit' :
    (el.type === 'checkbox' || el.type === 'radio') ? 'change' :
    (el.tagName === 'INPUT' || el.tagName === 'SELECT' || el.tagName === 'TEXTAREA') ? (el.tagName === 'SELECT' ? 'change' : 'input') :
    'click';

  // Default display fallback for elements when computed display is 'none'
  // Use uppercase tag checks (W3C guarantees) and compact ternary chain.
  const defaultDisplayForTag = el => {
    const t = el && el.tagName;
    return !t ? 'block' :
      (t === 'SPAN' || t === 'A' || t === 'STRONG' || t === 'EM' || t === 'B' || t === 'I' || t === 'IMG') ? 'inline' :
      (t === 'TR') ? 'table-row' :
      (t === 'TD' || t === 'TH') ? 'table-cell' :
      (t === 'LI') ? 'list-item' :
      (t === 'UL' || t === 'OL' || t === 'NAV' || t === 'SECTION' || t === 'DIV') ? 'block' :
      'block';
  };

  // Dynamic path helpers: support bracket-indexing like posts[indexs[0]].title
  const hasBracketIndex = s => typeof s === 'string' && s.indexOf('[') !== -1;
  // Collect root signal names referenced inside bracket expressions, used to subscribe to indirection signals
  const collectBracketRoots = s => {
    const roots = new Set();
    if(!s || s.indexOf('[') === -1) return roots;
    // find all bracket contents
    const re = /\[([^\]]+)\]/g; let m;
    while((m = re.exec(s)) !== null){
      const inner = m[1].trim();
      // inner may be like 'indexs[0]' or 'someSignal' or 'some.path'
      const base = inner.split(/[\.\[]/)[0];
      if(base) roots.add(toCamel(base));
    }
    return roots;
  };

  // Resolve a path with bracket expressions into a concrete dotted path using `get` to evaluate signals
  const resolveBracketPath = (raw) => {
    if(!hasBracketIndex(raw)) return raw;
    const parts = [];
    // split on dots but keep bracketed segments together
    let buf = '';
    for(let i=0;i<raw.length;i++){
      const ch = raw[i];
      if(ch === '.'){
        if(buf !== ''){ parts.push(buf); buf = ''; } else parts.push('');
        continue;
      }
      buf += ch;
    }
    if(buf !== '') parts.push(buf);
    const out = [];
    for(const p of parts){
      if(!p) continue;
      const m = p.match(/^([^\[]+)\[(.+)\]$/);
      if(!m){ out.push(toCamel(p)); continue; }
      const base = m[1];
      const inner = m[2];
      out.push(toCamel(base));
      // evaluate inner: support patterns like `indexs[0]` or `idx` or numeric literal
      const innerMatch = inner.match(/^([^\[]+)\[(\d+)\]$/);
      if(innerMatch){
        // inner is like foo[0] -> get('foo')[0]
        const sig = innerMatch[1]; const idx = Number(innerMatch[2]);
        const arr = get(String(sig));
        const val = (Array.isArray(arr) && arr.length > idx) ? arr[idx] : undefined;
        out.push(String(val));
        continue;
      }
      // inner numeric literal
      if(/^\d+$/.test(inner)) { out.push(String(Number(inner))); continue; }
      // inner is signal path -> get it and if it's array-like and numeric index access not present, use as-is
      const val = get(String(inner));
      out.push(String(val));
    }
    return out.join('.');
  };

  // Compile JS expression with caching
  // New simplified compile: expressions reference the global state explicitly via `dm`.
  // Example: use `dm.user.name` or `dm.count * 2`. This avoids identifier guessing.
  const compile = body => {
    if(fnCache.has(body)) return fnCache.get(body);
    let inner;
    try {
      // signature: (dm, el, ev, sg, detail)
      // dm is a plain object built from the internal signal Map (S), so expressions
      // can read values as `dm.foo` or `dm.user.name`.
      inner = new Function('dm','el','ev','sg','detail', `try{ return (${body}); }catch(e){ console.error(e); return undefined; }`);
    } catch(e) {
      console.error('[dmax] Failed to compile expression:', body.slice(0, 50) + (body.length > 50 ? '...' : ''), e);
      inner = () => undefined;
    }
    // Phase 1.4: Error boundary with expression context
    const wrapped = (dm, el, ev, sg, detail) => {
      try { 
        return inner(dm, el, ev, sg, detail); 
      } catch (e) { 
        console.error('[dmax] Expression failed:', body.slice(0, 60) + (body.length > 60 ? '...' : ''), e);
        return undefined; 
      }
    };
    fnCache.set(body, wrapped);
    return wrapped;
  };

  // Phase 1.1: Validation helpers
  const RESERVED_NAMES = ['ev', 'el', 'sg', 'dm', 'detail'];
  const VALID_MODIFIERS = ['immediate', 'notimmediate', 'once', 'always', 'debounce', 'throttle', 'prevent', 'and', 'notand', 'gt', 'lt', 'eq', 'gte', 'lte', 'neq', 'shape', 'content'];
  
  const isValidSignalName = (name) => {
    if (!name || typeof name !== 'string') return false;
    // Strip trailing state modifiers (?busy, ?err, etc.) for validation
    const cleanName = name.split('?')[0];
    // Check if starts with reserved name
    const firstPart = cleanName.split('.')[0].split('[')[0];
    if (RESERVED_NAMES.includes(firstPart)) return false;
    // Must start with letter, contain only alphanumeric/underscore/hyphen/brackets/dots
    if (!/^[a-z][a-zA-Z0-9_\-.\[\]]*$/.test(cleanName)) return false;
    // Check for malformed patterns
    if (cleanName.startsWith('.') || cleanName.endsWith('.')) return false;
    if (cleanName.includes('..')) return false;
    if (/^\d/.test(firstPart)) return false; // Can't start with number
    return true;
  };

  const isValidPropName = (name) => {
    if (!name || typeof name !== 'string') return false;
    // Properties must be kebab-case OR already camelCase (internal)
    // Allow leading dash for inverse classes
    const normalized = name.startsWith('-') ? name.slice(1) : name;
    // Allow both kebab-case and camelCase (since this checks after normalizePath)
    if (!/^[a-z][a-zA-Z0-9\-._]*$/.test(normalized)) return false;
    // Check for malformed patterns
    if (normalized.startsWith('.') || normalized.endsWith('.') || normalized.endsWith('-')) return false;
    if (normalized.includes('..') || normalized.includes('--')) return false;
    // NOTE: We don't reject camelCase here because propPath may already be normalized
    return true;
  };

  const isValidModifier = (modName) => {
    if (!modName) return false;
    // Modifier can have a dot+value (e.g., debounce.100, gt.5)
    const baseMod = modName.split('.')[0];
    return VALID_MODIFIERS.includes(baseMod);
  };

  const validateParsedItem = (item, context) => {
    if (item.type === 'signal') {
      if (!isValidSignalName(item.name)) {
        console.error(`[dmax] Invalid signal name in ${context}: "${item.name}"`);
        return false;
      }
    } else if (item.type === 'prop') {
      // propPath can be null for auto-detection
      if (item.propPath && !isValidPropName(item.propPath)) {
        console.error(`[dmax] Invalid property name in ${context}: "${item.propPath}"`);
        return false;
      }
    } else if (item.type === 'special' || item.type === 'event') {
      // Don't validate special/event names (window, document, click, etc.)
      // These have different patterns
    }
    // Validate modifiers
    const mods = item.mods || {};
    for (const modName of Object.keys(mods)) {
      if (!isValidModifier(modName)) {
        console.error(`[dmax] Invalid modifier in ${context}: "__${modName}"`);
        return false;
      }
    }
    return true;
  };

  function parseModsFast(s, i, n) {
    const mods = {};
    while (i < n && s.charCodeAt(i) === CC.UNDERSCORE && s.charCodeAt(i+1) === CC.UNDERSCORE) {
      i += 2;
      const start = i;
      while (i < n) {
        const cc = s.charCodeAt(i);
        if (cc === CC.DOT || cc === CC.COLON || cc === CC.AT || (cc === CC.UNDERSCORE && s.charCodeAt(i+1) === CC.UNDERSCORE)) break;
        i++;
      }
      const name = s.slice(start, i);
      if (!name) return [null, i];
      let val = 1;
      if (i < n && s.charCodeAt(i) === CC.DOT) {
        i++;
        const vs = i;
        while (i < n) {
          const cc = s.charCodeAt(i);
          if (cc === CC.COLON || cc === CC.AT || (cc === CC.UNDERSCORE && s.charCodeAt(i+1) === CC.UNDERSCORE)) break;
          i++;
        }
        const raw = s.slice(vs, i) || '';
        if (raw !== '' && !Number.isNaN(Number(raw))) val = +raw; else val = raw;
      }
      mods[name] = val;
    }
    return [mods, i];
  }

  function parseDataAttrFast(attr, prefixLen) {
    const s = attr;
    const n = s.length;
    let i = prefixLen;
    let gm = {};
    if (i + 1 < n && s.charAt(i) === '_' && s.charAt(i+1) === '_') {
      const r = parseModsFast(s, i, n);
      if (r[0] === null) return null;
      gm = r[0];
      i = r[1];
    }
    const targets = [];
    const triggers = [];

    function normalizePath(path) {
      if (!path) return null;
      const parts = path.split('.');
      const out = [];
      for (let j = 0; j < parts.length; ++j) {
        const seg = parts[j];
        if (/[A-Z]/.test(seg)) { console.error('CamelCase in attr name is invalid:', attr); return null; }
        if (seg.indexOf('-') === -1) { if (seg === '') return null; out.push(seg); continue; }
        const leading = seg[0] === '-';
        const pieces = seg.split('-');
        let idx = 0;
        if (pieces[0] === '') idx = 1;
        if (idx >= pieces.length) { console.error('Invalid kebab segment in attr name:', attr); return null; }
        if (pieces[pieces.length - 1] === '') { console.error('Trailing hyphen in attr name is invalid:', attr); return null; }
        for (let k = idx; k < pieces.length; ++k) if (pieces[k] === '') { console.error('Consecutive hyphens in attr name are invalid:', attr); return null; }
        const segToConvert = pieces.slice(idx).join('-');
        const camel = toCamel(segToConvert);
        out.push(leading ? ('-' + camel) : camel);
      }
      return out.join('.');
    }

    while (i < n) {
      const c = s.charAt(i);
      if (c === ':') {
        i++;
        if (i >= n) return null;
        const c2 = s.charAt(i);
        if (c2 === '#') {
          i++;
          let j = i; while (j < n && '.:@_'.indexOf(s[j]) === -1) j++;
          const id = s.slice(i, j); i = j;
          let prop = null;
          if (i < n && s.charAt(i) === '.') {
            i++; let k = i; while (k < n && ':@'.indexOf(s[k]) === -1) k++; let raw = s.slice(i, k); if (raw) { const mi = raw.indexOf('__'); if (mi !== -1) { raw = raw.slice(0, mi); } } prop = raw ? normalizePath(raw) : null; if (prop === null && raw !== null) return null; i = k;
          }
          let mr = [ {}, i ];
          if (i + 1 < n && s.charAt(i) === '_' && s.charAt(i+1) === '_') mr = parseModsFast(s, i, n);
          if (mr[0] === null) return null; i = mr[1];
          const merged0 = Object.assign({}, gm, mr[0]); if (merged0.always !== undefined) delete merged0.once;
          targets.push({type:'prop', elemId:id, propPath:prop, isCurr:false, mods:merged0});
        } else if (c2 === '.') {
          i++; let j = i; while (j < n && ':@'.indexOf(s[j]) === -1) j++; let raw = s.slice(i, j); i = j; let nm = raw || null; if (nm) { const mi = nm.indexOf('__'); if (mi !== -1) nm = nm.slice(0, mi); } const prop = nm ? normalizePath(nm) : null; if (prop === null && nm !== null) return null; let mr = [ {}, i ]; if (i + 1 < n && s.charAt(i) === '_' && s.charAt(i+1) === '_') mr = parseModsFast(s, i, n); if (mr[0] === null) return null; i = mr[1]; const merged1 = Object.assign({}, gm, mr[0]); if (merged1.always !== undefined) delete merged1.once; targets.push({type:'prop', elemId:'', propPath:prop, isCurr:true, mods:merged1});
        } else {
          let j = i; while (j < n && ':@_'.indexOf(s[j]) === -1) j++; let raw = s.slice(i, j); i = j; if (!raw) return null; const mi = raw.indexOf('__'); if (mi !== -1) { raw = raw.slice(0, mi); } const name = normalizePath(raw); if (name === null) return null; let mr = [ {}, i ]; if (i + 1 < n && s.charAt(i) === '_' && s.charCodeAt(i+1) === CC.UNDERSCORE) mr = parseModsFast(s, i, n); if (mr[0] === null) return null; i = mr[1]; const merged2 = Object.assign({}, gm, mr[0]); if (merged2.always !== undefined) delete merged2.once; targets.push({type:'signal', name, mods:merged2});
        }
      } else if (c === '@') {
        i++; if (i >= n) return null; const c2 = s.charAt(i);
        if (c2 === '_') {
          i++; let j = i; while (j < n && '.:@_'.indexOf(s[j]) === -1) j++; const tok = s.slice(i, j); i = j; if (!tok) return null; let arg = null; if (i < n && s.charAt(i) === '.') { i++; let k = i; while (k < n && ':@_'.indexOf(s[k]) === -1) k++; arg = s.slice(i, k) || null; i = k; } let mr = [ {}, i ]; if (i + 1 < n && s.charAt(i) === '_' && s.charAt(i+1) === '_') mr = parseModsFast(s, i, n); if (mr[0] === null) return null; i = mr[1]; const merged3 = Object.assign({}, gm, mr[0]); if (merged3.always !== undefined) delete merged3.once; triggers.push({type:'special', name:tok, arg, mods:merged3});
        } else if (c2 === '#') {
          i++; let j = i; while (j < n && '.:@_'.indexOf(s[j]) === -1) j++; const id = s.slice(i, j); i = j; let ev = null; if (i < n && s.charAt(i) === '.') { i++; let k = i; while (k < n && ':@'.indexOf(s[k]) === -1) k++; let raw = s.slice(i, k) || null; ev = raw ? normalizePath(raw) : null; if (ev === null && raw !== null) return null; i = k; } let mr = [ {}, i ]; if (i + 1 < n && s.charAt(i) === '_' && s.charAt(i+1) === '_') mr = parseModsFast(s, i, n); if (mr[0] === null) return null; i = mr[1]; const merged4 = Object.assign({}, gm, mr[0]); if (merged4.always !== undefined) delete merged4.once; triggers.push({type:'event', elemId:id, eventName:ev, isCurr:false, mods:merged4});
        } else if (c2 === '.') {
          i++; let j = i; while (j < n && ':@_'.indexOf(s[j]) === -1) j++; let raw = s.slice(i, j) || null; i = j; let ev = raw ? normalizePath(raw) : null; if (ev === null && raw !== null) return null; let mr = [ {}, i ]; if (i + 1 < n && s.charAt(i) === '_' && s.charAt(i+1) === '_') mr = parseModsFast(s, i, n); if (mr[0] === null) return null; i = mr[1]; const merged5 = Object.assign({}, gm, mr[0]); if (merged5.always !== undefined) delete merged5.once; triggers.push({type:'event', elemId:'', eventName:ev, isCurr:true, mods:merged5});
        } else {
          let j = i; while (j < n && ':@_'.indexOf(s[j]) === -1) j++; let raw = s.slice(i, j); i = j; if (!raw) return null; let name = normalizePath(raw); if (name === null) return null; let mr = [ {}, i ]; if (i + 1 < n && s.charAt(i) === '_' && s.charAt(i+1) === '_') mr = parseModsFast(s, i, n); if (mr[0] === null) return null; i = mr[1]; const merged6 = Object.assign({}, gm, mr[0]); if (merged6.always !== undefined) delete merged6.once; triggers.push({type:'signal', name, mods:merged6});
        }
      } else {
        return null;
      }
      if (i < n && s.charAt(i) !== ':' && s.charAt(i) !== '@') return null;
    }
    if (!targets.length && !triggers.length) return null;
    
    // Phase 1.1: Validate all parsed targets and triggers
    for (const target of targets) {
      if (!validateParsedItem(target, attr)) return null;
    }
    for (const trigger of triggers) {
      if (!validateParsedItem(trigger, attr)) return null;
    }
    
    return {targets, triggers};
  }

  // Phase 1.3: Element resolution with warnings
  const getElById = (id, context = 'element reference') => {
    if (!id) return null;
    const el = document.getElementById(id);
    if (!el) {
      console.warn(`[dmax] Element #${id} not found in ${context}`);
    }
    return el;
  };

  // Set property (fast, supports nested)
  // Phase 2.2: Fast-path for single-level properties (90% of cases)
  const setProp = (el, path, val) => {
    if(!path) path = getAutoProp(el);
    
    // Fast path: no nested access
    if(path.indexOf('.') === -1) {
      const key = toCamel(path);
      try {
        if(el[key] !== val) el[key] = val;
      } catch(e) {
        console.error('Failed to set property', path, 'on', el, e);
      }
      return;
    }
    
    // Nested path (slower)
    const parts = path.split('.');
    let t = el;
    try {
      for(let i = 0; i < parts.length - 1; i++) {
        let key = parts[i];
        // Support array indexes: foo.0.bar
        if(/^\d+$/.test(key)) key = +key;
        t = t[toCamel(key)];
        if(!t) throw new Error('Invalid property path');
      }
      let last = parts[parts.length - 1];
      if(/^\d+$/.test(last)) last = +last;
      last = toCamel(last);
      if(t && t[last] !== val) t[last] = val;
    } catch(e) {
      console.error('Failed to set property', path, 'on', el, e);
    }
  };

  // Track all event listeners and signal handlers for cleanup
  const cleanupMap = new WeakMap();

  // Applier factories for Phase 3b
  const createSubApplier = (target, targetEl) => {
    if(target.type === 'signal'){
      if(hasBracketIndex(target.name)){
        return res => {
          try{ const resolved = resolveBracketPath(target.name); if(resolved) set(resolved, res); }catch(e){}
        };
      }
      return (res, isSignalInvocation) => {
        try{ }catch(e){}
        if(isSignalInvocation) set(target.name, res); else set(target.name, res, true);
      };
    }
    const prop = target.propPath || null;
    return res => setProp(targetEl, prop, res);
  };

  const createClassApplier = (target, targetEl) => {
    const classes = (target.propPath || '').split('.').filter(Boolean).map(c => ({name: c[0] === '-' ? c.slice(1) : c, remove: c[0] === '-'}));
    return res => {
      for(const c of classes){
        if(c.remove){
          if(res) targetEl.classList.remove(c.name);
          else targetEl.classList.add(c.name);
        } else {
          if(res) targetEl.classList.add(c.name);
          else targetEl.classList.remove(c.name);
        }
      }
    };
  };

  const createDispApplier = (targetEl) => {
    // Cache original display and whether it was an inline style
    const inline = targetEl.style && targetEl.style.display ? targetEl.style.display : '';
    const computed = (typeof window !== 'undefined' && window.getComputedStyle) ? window.getComputedStyle(targetEl).display : '';
    const hadInline = inline !== '';
    const originalDisplay = hadInline ? inline : (computed === 'none' ? defaultDisplayForTag(targetEl) : computed);
    return res => {
      if(res){
        if(hadInline) targetEl.style.display = originalDisplay;
        else {
          const now = (typeof window !== 'undefined' && window.getComputedStyle) ? window.getComputedStyle(targetEl).display : '';
          if(now === 'none') targetEl.style.display = originalDisplay; else targetEl.style.removeProperty('display');
        }
      } else {
        targetEl.style.display = 'none';
      }
    };
  };

  // Generic setup for data-sub, data-class, data-disp
  function setupGeneric(type, el, attr, body) {
    const parsed = parseDataAttrFast(attr, type === 'data-sub' ? 8 : (type === 'data-class' ? 10 : 9));
    if(!parsed) {
      console.error(`[dmax] Failed to parse ${type} attribute: "${attr}"`);
      return;
    }
    const {targets, triggers} = parsed;
    const fn = compile(body);
    // Precompute appliers for targets to minimize work on each trigger
    const appliers = targets.map(t => {
      const targetEl = t.elemId ? getElById(t.elemId, attr) : el;
      if(!targetEl) return null;
      if(type === 'data-sub') return createSubApplier(t, targetEl);
      if(type === 'data-class') return createClassApplier(t, targetEl);
      if(type === 'data-disp') return createDispApplier(targetEl);
      return null;
    });

    const handler = (ev, sg, detailArg) => {
      const detailParam = ev && ev.detail && ev.detail.change ? ev.detail.change : detailArg;
      // If this invocation is signal-originated (ev is null/undefined), do not
      // pass `ev` into compiled functions â€” pass undefined instead; compiled
      // bodies receive the change info via the `detail` parameter.
      const isSignalInvocation = (ev == null);
      const evArg = isSignalInvocation ? undefined : ev;
      const result = fn(dmProxy, el, evArg, sg, detailParam);
      if(!appliers || appliers.length === 0) return;
      try {
        for(const ap of appliers) if(ap) ap(result, isSignalInvocation);
      } catch(e) { console.error('Applier error', e); }
    };
    // Track listeners for cleanup
    let listeners = cleanupMap.get(el);
    if(!listeners) listeners = [], cleanupMap.set(el, listeners);
    for(let t of triggers){
      // build a decorated handler that supports modifier semantics: __prevent, __once, __debounce, __throttle, __and
      const makeDecorated = (orig, t, opts = {}) => {
        const { mods = {} } = t;
        const debMs = mods.debounce == null ? null : +mods.debounce;
        const thrMs = mods.throttle == null ? null : +mods.throttle;
        const once = 'once' in mods;
        const prevent = 'prevent' in mods;
        const andPath = mods.and ?? null;
        const notandPath = mods.notand ?? null;
        const guardEq = 'eq' in mods ? mods.eq : undefined;
        const guardNe = 'ne' in mods ? mods.ne : undefined;
        const guardGt = 'gt' in mods ? +mods.gt : undefined;
        const guardGe = 'ge' in mods ? +mods.ge : undefined;
        const guardLt = 'lt' in mods ? +mods.lt : undefined;
        const guardLe = 'le' in mods ? +mods.le : undefined;
        let timer = null;
        let last = 0;
        const decorated = function(ev, sg, detailArg){
          if (prevent) ev?.preventDefault?.();
          const run = () => {
            if (andPath && !get(String(andPath))) return;
            if (notandPath && get(String(notandPath))) return;
            const subjectVal = t.type === 'signal' ? get(String(t.name)) : ev?.detail?.ms;
            if (guardEq !== undefined && String(subjectVal) !== String(guardEq)) return;
            if (guardNe !== undefined && String(subjectVal) === String(guardNe)) return;
            if (guardGt !== undefined && !(+subjectVal > guardGt)) return;
            if (guardGe !== undefined && !(+subjectVal >= guardGe)) return;
            if (guardLt !== undefined && !(+subjectVal < guardLt)) return;
            if (guardLe !== undefined && !(+subjectVal <= guardLe)) return;
            try { orig(ev, sg, detailArg); } catch (e) { console.error('Handler error', e); }
            if (once && decorated && decorated.remove) decorated.remove();
          };
          if (debMs != null) { clearTimeout(timer); timer = setTimeout(run, debMs); return; }
          if (thrMs != null) { const now = Date.now(); if (now - last >= thrMs) { last = now; run(); } return; }
          run();
        };
        return decorated;
      };

        if(t.type === 'signal'){
        const rootRaw = String(t.name).split('.')[0];
        const rootBase = (rootRaw.indexOf('[') !== -1) ? rootRaw.split('[')[0] : rootRaw;
        const root = toCamel(rootBase);
        const rootAlias = sigKey(rootBase);
        if(!subs.has(root)) subs.set(root, []);
        if(rootAlias !== root && !subs.has(rootAlias)) subs.set(rootAlias, []);
        const dec = makeDecorated(handler, t);
        // allow removal for __once and other removals; handle both legacy function entries and object entries
        dec.remove = () => {
          const arr = subs.get(root) || [];
          subs.set(root, arr.filter(it => (typeof it === 'function' ? it !== dec : it.fn !== dec)));
          if(rootAlias !== root){ const arr2 = subs.get(rootAlias) || []; subs.set(rootAlias, arr2.filter(it => (typeof it === 'function' ? it !== dec : it.fn !== dec))); }
        };
        // support __shape modifier: register subscription object with optional childPath
        let entry = dec;
        if(t.mods && ('shape' in t.mods || 'content' in t.mods)){
          const sval = (t.mods && 'shape' in t.mods) ? ((t.mods.shape === true || t.mods.shape === 1) ? null : (t.mods.shape != null ? String(t.mods.shape) : null)) : null;
          entry = { fn: dec, mode: ('shape' in t.mods ? 'shape' : 'content'), childPath: sval };
        }
        // If trigger uses bracket-index indirection, wrap the handler so it only fires when the resolved path matches
        if(hasBracketIndex(t.name)){
          const wrapper = function(ev, p, detailArg){
            try{
              const resolved = resolveBracketPath(t.name);
              // debug trace
              console.log('WRAPPER', t.name, 'resolved->', resolved, 'p->', p);
              // if invoked because of index/root change (p is one of the extra roots) we should call handler
              const extraRoots = Array.from(collectBracketRoots(t.name));
              if(p && extraRoots.includes(p)){
                return dec(ev, p, detailArg);
              }
              if(!p) return;
              // if mutation path equals or is under resolved path, invoke
              if(resolved && (p === resolved || p.indexOf(resolved + '.') === 0)){
                return dec(ev, p, detailArg);
              }
            }catch(e){ }
          };
          const wrappedEntry = { fn: wrapper, mode: (t.mods && ('shape' in t.mods) ? 'shape' : 'content'), childPath: null };
          subs.get(root).push(wrappedEntry);
          if(rootAlias !== root) subs.get(rootAlias).push(wrappedEntry);
          // also subscribe wrapper to bracket roots (idx signals)
          const extraRoots = collectBracketRoots(t.name);
          for(const er of extraRoots){ if(er !== root){ if(!subs.has(er)) subs.set(er, []); subs.get(er).push(wrappedEntry); } }
        } else {
          subs.get(root).push(entry);
          if(rootAlias !== root) subs.get(rootAlias).push(entry);
        }
        listeners.push({type:'signal', root, handler: dec});
        if(rootAlias !== root) listeners.push({type:'signal', root: rootAlias, handler: dec});
        if(!t.mods?.notimmediate) dec(undefined, t.name);
        continue;
      }

      // Event triggers
      // Resolve target element: explicit id (`#id`) or current element
      let targetEl = null;
      let eventName = t.eventName || null;

      // Case: explicit element id â€” no legacy mappings, require real element id
      if(t.elemId){
        targetEl = getElById(t.elemId, attr);
        if(!targetEl){ console.error('Element not found for id:', t.elemId); }
      }

      // Case: new syntax uses `.window` or `.interval` as eventName while isCurr is true
      // Handle special triggers produced by the `_` token: @_window, @_document, @_form, @_interval, @_delay
      if(t.type === 'special'){
        const name = t.name;
        if(name === 'window'){
          const ev = (t.arg && String(t.arg)) || 'resize';
          window.addEventListener(ev, handler);
          listeners.push({type:'event', targetEl: window, eventName: ev, handler});
          if(t.mods?.immediate) handler();
          continue;
        }
        if(name === 'document'){
          const ev = (t.arg && String(t.arg)) || 'visibilitychange';
          document.addEventListener(ev, handler);
          listeners.push({type:'event', targetEl: document, eventName: ev, handler});
          if(t.mods?.immediate) handler();
          continue;
        }
        if(name === 'interval'){
          const ms = parseInt(t.arg) || 1000;
          const tick = () => {
            try{ handler(new CustomEvent('interval', {detail:{ms}})); }catch(e){}
          };
          const id = setInterval(tick, ms);
          listeners.push({type:'interval', id});
          if(t.mods?.immediate) tick();
          continue;
        }
        if(name === 'delay'){
          const ms = parseInt(t.arg) || 0;
          const id = setTimeout(() => {
            try{ handler(new CustomEvent('delay', {detail:{ms}})); }catch(e){}
          }, ms);
          listeners.push({type:'timeout', id});
          continue;
        }
        if(name === 'form'){
          // bind to closest form ancestor
          const formEl = el && el.closest ? el.closest('form') : null;
          if(formEl){
            const ev = (t.arg && String(t.arg)) || 'submit';
            formEl.addEventListener(ev, handler);
            listeners.push({type:'event', targetEl: formEl, eventName: ev, handler});
            if(t.mods?.immediate) handler();
          }
          continue;
        }
      }

      // If still no targetEl, fall back to current element
      if(!targetEl) targetEl = el;
      // Determine final event name
      const finalEvent = eventName || getAutoEvent(targetEl);
      if(targetEl === null){ console.error('Element not found:', t.elemId); continue; }
      // decorate handler with modifiers
      const dec = (function(orig, tt){
        const mods = tt.mods || {};
        const decorated = makeDecorated(orig, tt);
        decorated.remove = () => { try{ targetEl.removeEventListener(finalEvent, decorated); }catch(e){} };
        return decorated;
      })(handler, t);
      targetEl.addEventListener(finalEvent, dec);
      listeners.push({type:'event', targetEl, eventName: finalEvent, handler: dec});
      if(t.mods?.immediate) dec();
    }
    if(triggers.length === 0) handler();
  }

  // MutationObserver for cleanup
  const observer = new MutationObserver(records => {
    for(const rec of records){
      for(const node of rec.removedNodes){
        if(node.nodeType !== 1) continue;
        const listeners = cleanupMap.get(node);
        if(listeners){
          for(const l of listeners){
            if(l.type === 'event') l.targetEl.removeEventListener(l.eventName, l.handler);
            if(l.type === 'signal'){
              const arr = subs.get(l.root);
              if(arr) subs.set(l.root, arr.filter(it => (typeof it === 'function' ? it !== l.handler : it.fn !== l.handler)));
            }
            if(l.type === 'interval') clearInterval(l.id);
          }
          cleanupMap.delete(node);
        }
      }
    }
  });
  observer.observe(document.body, {childList:true, subtree:true});

  // Setup wrappers
  const setupSub = (el, attr, body) => setupGeneric('data-sub', el, attr, body);
  const setupClass = (el, attr, body) => setupGeneric('data-class', el, attr, body);
  const setupDisp = (el, attr, body) => setupGeneric('data-disp', el, attr, body);

  // --- Actions: data-get / data-post / data-put / data-patch / data-delete
  function parseActionAttr(attr) {
    // attr is full attribute name, e.g. 'data-post^json+#src.value:result?busy,err@.click'
    const s = attr;
    const methods = ['data-get','data-post','data-put','data-patch','data-delete'];
    let method = null;
    for(const m of methods) if(s.indexOf(m) === 0) { method = m.substring(5); break; }
    if(!method) return null;
    let i = attr.indexOf('data-' + method);
    if(i !== 0) i = 0; // defensive
    i = ('data-' + method).length;
    const headers = {};
    const headerShortcuts = [];
    const inputs = [];
    // parse optional result modifier immediately after `data-<method>` (e.g. __append/__prepend/__replace)
    let resultMod = null;
    while(i + 1 < s.length && s[i] === '_' && s[i+1] === '_'){
      // read modifier name (stop at separators: ^ + : @)
      i += 2;
      const startMod = i;
      while(i < s.length && s[i] !== '^' && s[i] !== '+' && s[i] !== ':' && s[i] !== '@' && !(s[i] === '_' && s[i+1] === '_')) i++;
      const modRaw = s.slice(startMod, i).split('.')[0] || '';
      if(modRaw) {
        if(modRaw === 'append' || modRaw === 'prepend' || modRaw === 'replace') resultMod = modRaw;
        // else: ignore unknown mods here (could be input-level or header-level later)
      }
    }
    // parse ^ tokens
    while(i < s.length && s[i] === '^'){
      i++; const start = i; while(i < s.length && s[i] !== '^' && s[i] !== '+' && s[i] !== ':' && s[i] !== '@' && s[i] !== '?') i++;
      const raw = s.slice(start, i);
      if(!raw) return null;
      headerShortcuts.push(raw);
      // simple mapping for json: handled at runtime; other name.value -> header
      if(raw.indexOf('.') !== -1){ const p = raw.split('.'); const name = p[0]; const val = p.slice(1).join('.'); headers[name.toLowerCase()] = val; }
    }
    // parse + inputs (support per-input mods e.g. +sig__query.qname or +#id.prop__body)
    while(i < s.length && s[i] === '+'){
      i++; const start = i;
      // read raw token until separator or start of mods
      while(i < s.length && s[i] !== '+' && s[i] !== ':' && s[i] !== '@' && s[i] !== '?' && !(s[i] === '_' && s[i+1] === '_')) i++;
      const raw = s.slice(start, i).trim();
      const input = {raw, mods:{}};
      // parse trailing mods for this input
      while(i < s.length && s[i] === '_' && s[i+1] === '_'){
        i += 2;
        const mstart = i;
        while(i < s.length){ const cc = s.charCodeAt(i); if(cc === CC.DOT || cc === CC.COLON || cc === CC.AT || (cc === CC.UNDERSCORE && s.charCodeAt(i+1) === CC.UNDERSCORE)) break; i++; }
        const mname = s.slice(mstart, i);
        let mval = true;
        if(i < s.length && s[i] === '.'){
          i++; const mvstart = i; while(i < s.length && s[i] !== '+' && s[i] !== ':' && s[i] !== '@' && !(s[i] === '_' && s[i+1] === '_') && s[i] !== '?') i++; mval = s.slice(mvstart, i) || true;
        }
        input.mods[mname] = mval;
      }
      inputs.push(input);
    }
    // now the rest may contain :target?stateList and triggers
    const rest = s.slice(i);
    // find where triggers (@) start
    const atIdx = rest.indexOf('@');
    let targetPart = rest;
    let triggerPart = '';
    if(atIdx !== -1){ targetPart = rest.slice(0, atIdx); triggerPart = rest.slice(atIdx); }
    // split targetPart on ? to extract state signals
    let targetSpec = targetPart;
    let stateSpecs = [];
    const qIdx = targetPart.indexOf('?');
    if(qIdx !== -1){
      targetSpec = targetPart.slice(0, qIdx);
      const st = targetPart.slice(qIdx+1);
      // parse state specs: allow mod suffix like name__busy
      stateSpecs = st.split(',').map(x=>x.trim()).filter(Boolean).map(sx => {
        const parts = sx.split('__');
        return {name: parts[0], mode: parts[1] || 'busy'};
      });
    }
    // Build a parseable string for parseDataAttrFast: ensure it starts with ':' or '@'
    let parseStr = (targetSpec || '') + (triggerPart || '');
    if(parseStr && parseStr[0] !== ':' && parseStr[0] !== '@') parseStr = ':' + parseStr;
    const parsed = parseDataAttrFast(parseStr, 0);
    if(!parsed) return null;
    return {method, headers, headerShortcuts, inputs, stateSpecs, parsed, resultMod};
  }

  async function setupAction(el, attr, url) {
    const info = parseActionAttr(attr);
    if(!info) { console.error('Malformed action attribute', attr); return; }
    const {method, headers, headerShortcuts, inputs, stateSpecs, parsed} = info;
    // For now only support JSON shortcut
    const hdrs = Object.assign({}, headers);
    for(const h of headerShortcuts){ if(h === 'json'){ hdrs['content-type'] = 'application/json'; hdrs['accept'] = 'application/json'; } }

    // For now only support a single signal target (first signal target)
    const target = parsed.targets.find(t => t.type === 'signal');
    if(!target){ console.error('Action requires a signal target (e.g. :result)'); }
    // derive result modifier from target mods: __replace (default), __append, __prepend
    if(target && target.mods){
      if(target.mods.append !== undefined) info.resultMod = 'append';
      else if(target.mods.prepend !== undefined) info.resultMod = 'prepend';
      else if(target.mods.replace !== undefined) info.resultMod = 'replace';
    }

    // Ensure state signals exist (create defaults) and map spec modes
    const stateMap = []; // {name, camel, mode}
    if(Array.isArray(stateSpecs) && stateSpecs.length){
      for(const s of stateSpecs){
        if(!s || !s.name) continue;
        const camel = toCamel(s.name);
        const mode = s.mode || 'busy';
        // create default initial values per mode
        if(mode === 'busy') { if(!S.has(camel)) S.set(camel, false); }
        else if(mode === 'done') { if(!S.has(camel)) S.set(camel, false); }
        else if(mode === 'err') { if(!S.has(camel)) S.set(camel, false); }
        else if(mode === 'ok') { if(!S.has(camel)) S.set(camel, true); }
        else if(mode === 'code') { if(!S.has(camel)) S.set(camel, null); }
        else if(mode === 'all') { if(!S.has(camel)) S.set(camel, {busy:false,done:false,err:false,ok:true,code:null}); }
        stateMap.push({name: s.name, camel, mode});
      }
    }

    const doRequest = async (ev, sg) => {
      // build params/body from inputs
      let body = null;
      const queryParams = {};
      const bodyFields = {};
      if(Array.isArray(inputs) && inputs.length){
        for(const inp of inputs){
          const raw = inp.raw || '';
          // element reference
          if(raw[0] === '#'){
            const parts = raw.slice(1).split('.'); const elem = getElById(parts[0], attr); const prop = parts.slice(1).join('.') || getAutoProp(elem);
            const val = elem ? (elem[toCamel(prop)] ?? elem.value ?? null) : null;
            // decide where to place val based on mods or default
            if(inp.mods['query']){
              const name = inp.mods['query'] === true ? (parts[parts.length-1]) : inp.mods['query'];
              queryParams[name] = val;
            } else if(inp.mods['body']){
              // body mapping -> collect into bodyFields
              const name = inp.mods['body'] === true ? (parts[parts.length-1]) : inp.mods['body'];
              bodyFields[name] = val;
            } else if(method === 'get' || method === 'delete'){
              const name = inp.mods['query'] === undefined ? (parts[parts.length-1]) : inp.mods['query'];
              queryParams[name] = val;
            } else {
              // default for non-GET: treat as body field
              const name = parts[parts.length-1];
              bodyFields[name] = val;
            }
            if(inp.mods['header']){
              const hname = inp.mods['header'] === true ? (`x-dmax-${parts[parts.length-1]}`) : inp.mods['header'];
              hdrs[hname.toLowerCase()] = String(val);
            }
          } else {
            // signal input
            const sig = raw.replace(/^\./,'');
            const val = get(sig);
            const last = sig.split('.').pop();
            if(inp.mods['query']){
              const name = inp.mods['query'] === true ? last : inp.mods['query'];
              queryParams[name] = val;
            } else if(inp.mods['body']){
              const name = inp.mods['body'] === true ? last : inp.mods['body'];
              bodyFields[name] = val;
            } else if(method === 'get' || method === 'delete'){
              const name = last;
              queryParams[name] = val;
            } else {
              // default for non-GET: collect into bodyFields
              bodyFields[last] = val;
            }
            if(inp.mods['header']){
              const hname = inp.mods['header'] === true ? (`x-dmax-${last}`) : inp.mods['header'];
              hdrs[hname.toLowerCase()] = String(val);
            }
          }
        }
      }
      // finalize body: support dotted keys -> nested object
      function setDeep(obj, path, value){
        const parts = String(path).split('.');
        let cur = obj;
        for(let i=0;i<parts.length;i++){
          const p = parts[i];
          if(i === parts.length-1){ cur[p] = value; }
          else { if(typeof cur[p] !== 'object' || cur[p] === null) cur[p] = {}; cur = cur[p]; }
        }
      }
      const bfKeys = Object.keys(bodyFields);
      if(bfKeys.length === 1){
        const k = bfKeys[0];
        if(k.indexOf('.') !== -1){ const o = {}; setDeep(o, k, bodyFields[k]); body = o; }
        else { body = bodyFields[k]; }
      } else if(bfKeys.length > 1){
        const o = {};
        for(const k of bfKeys){ setDeep(o, k, bodyFields[k]); }
        body = o;
      }

      // set initial state signals (before request)
      for(const s of stateMap){
        if(s.mode === 'busy') set(s.camel, true);
        else if(s.mode === 'done') set(s.camel, false);
        else if(s.mode === 'err') set(s.camel, false);
        else if(s.mode === 'ok') set(s.camel, false);
        else if(s.mode === 'code') set(s.camel, null);
        else if(s.mode === 'all') set(s.camel, {busy:true, done:false, err:false, ok:false, code:null});
      }

      try{
        // assemble final URL with query params for GET/DELETE
        let finalUrl = url;
        const paramKeys = Object.keys(queryParams);
        if(paramKeys.length && (method === 'get' || method === 'delete')){
          const q = paramKeys.map(k => encodeURIComponent(k) + '=' + encodeURIComponent(String(queryParams[k] ?? ''))).join('&');
          finalUrl += (finalUrl.indexOf('?') === -1 ? '?' : '&') + q;
        }

        const init = { method: method.toUpperCase(), headers: {} };
        // only JSON supported for now
        if(hdrs['content-type']) init.headers['Content-Type'] = hdrs['content-type'];
        if(hdrs['accept']) init.headers['Accept'] = hdrs['accept'];
        if(body != null){ if(init.headers['Content-Type'] && init.headers['Content-Type'].includes('application/json')) init.body = JSON.stringify(body); else init.body = String(body); }
        const res = await fetch(finalUrl, init);
        const ok = res.ok;
        let payload = null;
        const ct = res.headers.get('content-type') || '';
        if(ct.indexOf('application/json') !== -1){ payload = await res.json(); }
        else { payload = await res.text(); }
        if(target && target.type === 'signal'){
          // handle result modifier: replace (default), append, prepend
          const mod = info.resultMod || 'replace';
          const targetSignal = toCamel(target.name);
          try{
            if(mod === 'replace'){
              set(targetSignal, payload);
            } else if(mod === 'append' || mod === 'prepend'){
              const curr = get(targetSignal);
              const items = Array.isArray(payload) ? payload.slice() : [payload];
              let base = Array.isArray(curr) ? curr.slice() : (curr == null ? [] : [curr]);
              let out;
              if(mod === 'append') out = base.concat(items);
              else out = items.concat(base);
              set(targetSignal, out);
            } else {
              // unknown modifier: fallback to replace
              set(targetSignal, payload);
            }
          }catch(e){ console.error('Failed applying result modifier', e); set(targetSignal, payload); }
        }
        // update state signals on success
        for(const s of stateMap){
          if(s.mode === 'busy') set(s.camel, false);
          else if(s.mode === 'done') set(s.camel, true);
          else if(s.mode === 'err') set(s.camel, false);
          else if(s.mode === 'ok') set(s.camel, true);
          else if(s.mode === 'code') set(s.camel, res.status);
          else if(s.mode === 'all') set(s.camel, {busy:false, done:true, err:false, ok:true, code:res.status});
        }
      } catch(err){
        // update state signals on error
        for(const s of stateMap){
          if(s.mode === 'busy') set(s.camel, false);
          else if(s.mode === 'done') set(s.camel, false);
          else if(s.mode === 'err') set(s.camel, true);
          else if(s.mode === 'ok') set(s.camel, false);
          else if(s.mode === 'code') set(s.camel, (err && err.status) || null);
          else if(s.mode === 'all') set(s.camel, {busy:false, done:false, err:true, ok:false, code:(err && err.status) || null});
        }
        if(stateMap.length === 0){
          // fall back to previous simple behavior
          if(stateSpecs[0]) set(stateSpecs[0], false);
          if(stateSpecs[1]) set(stateSpecs[1], err && err.message ? err.message : String(err));
        }
        console.error('Action fetch error', err);
      }
    };

    // Register triggers using parsed.triggers
    for(const t of parsed.triggers){
      if(t.type === 'signal'){
      const rootRaw = String(t.name).split('.')[0];
      const rootBase = (rootRaw.indexOf('[') !== -1) ? rootRaw.split('[')[0] : rootRaw;
      const root = toCamel(rootBase);
      const rootAlias = sigKey(rootBase);
        if(!subs.has(root)) subs.set(root, []);
        if(rootAlias !== root && !subs.has(rootAlias)) subs.set(rootAlias, []);
        const handler = () => doRequest(undefined, t.name);
        // support __shape / __content modifiers on trigger subscriptions
        let entry = handler;
        if(t.mods && ('shape' in t.mods || 'content' in t.mods)){
          const sval = (t.mods && 'shape' in t.mods) ? ((t.mods.shape === true || t.mods.shape === 1) ? null : (t.mods.shape != null ? String(t.mods.shape) : null)) : null;
          entry = { fn: handler, mode: ('shape' in t.mods ? 'shape' : 'content'), childPath: sval };
        }
        subs.get(root).push(entry);
        if(rootAlias !== root) subs.get(rootAlias).push(entry);
        // Extra subscriptions when trigger uses bracket indirection
        if(hasBracketIndex(t.name)){
          const extraRoots = collectBracketRoots(t.name);
          for(const er of extraRoots){ if(er !== root){ if(!subs.has(er)) subs.set(er, []); subs.get(er).push(entry); } }
        }
        if(!t.mods?.notimmediate) handler();
      } else if(t.type === 'event' || t.type === 'special'){
        if(t.type === 'special' && t.name === 'interval'){
          const ms = parseInt(t.arg) || 1000;
          const id = setInterval(()=> doRequest(new CustomEvent('interval',{detail:{ms}})), ms);
          // track cleanup
          let listeners = cleanupMap.get(el); if(!listeners) listeners = [], cleanupMap.set(el, listeners);
          listeners.push({type:'interval', id});
        } else if(t.type === 'special' && t.name === 'delay'){
          const ms = parseInt(t.arg) || 0;
          setTimeout(()=> doRequest(new CustomEvent('delay',{detail:{ms}})), ms);
        } else if(t.type === 'special' && t.name === 'window'){
          const evName = t.arg || 'resize'; window.addEventListener(evName, doRequest); let listeners = cleanupMap.get(window); if(!listeners) listeners = [], cleanupMap.set(window, listeners); listeners.push({type:'event', targetEl: window, eventName: evName, handler: doRequest});
        } else {
          const targetEl = t.elemId ? getElById(t.elemId, attr) : el;
          if(!targetEl) continue;
          const evName = t.eventName || getAutoEvent(targetEl);
          targetEl.addEventListener(evName, doRequest);
          let listeners = cleanupMap.get(targetEl); if(!listeners) listeners = [], cleanupMap.set(targetEl, listeners);
          listeners.push({type:'event', targetEl, eventName: evName, handler: doRequest});
        }
      }
    }
  }

  // Two-way sync for data-sync:target.path
  function setupSync(el, attr) {
    // Enhanced sync: support directional forms via parseDataAttrFast
    // Examples supported:
    // - data-sync@sig            => signal -> element (one-way)
    // - data-sync:foo@.value     => element.prop -> signal (one-way)
    // - data-sync:foo:.value     => two-way (both directions)
    const parsed = parseDataAttrFast(attr, 9);
    
    if(!parsed){
      // fallback to old behavior for simple `data-sync:foo` forms
      const colon = attr.indexOf(':');
      const path = colon === -1 ? '' : attr.substring(colon + 1);
      if(!path) return;
      const root = toCamel(path.split('.')[0]);
      const rootAlias = sigKey(path.split('.')[0]);
      const update = () => {
        const val = get(path);
        const prop = getAutoProp(el);
        try {
          if(prop === 'checked') el.checked = Boolean(val);
          else if(prop === 'value') el.value = val == null ? '' : val;
          else el.textContent = val == null ? '' : val;
        } catch(e) { console.error('Failed to apply sync value', e); }
      };
      update();
      if(!subs.has(root)) subs.set(root, []);
      if(rootAlias !== root && !subs.has(rootAlias)) subs.set(rootAlias, []);
      subs.get(root).push(update);
      if(rootAlias !== root) subs.get(rootAlias).push(update);
      let listeners = cleanupMap.get(el);
      if(!listeners) listeners = [], cleanupMap.set(el, listeners);
      listeners.push({type:'signal', root, handler: update});
      const evName = getAutoEvent(el);
      const write = () => {
        const prop = getAutoProp(el);
        const val = prop === 'checked' ? el.checked : (prop === 'value' ? el.value : el.textContent);
        set(path, val);
      };
      el.addEventListener(evName, write);
      listeners.push({type:'event', targetEl: el, eventName: evName, handler: write});
      return;
    }

    // Determine signal target and prop target (if any)
    const sigTargets = parsed.targets.filter(t => t.type === 'signal');
    const propTargets = parsed.targets.filter(t => t.type === 'prop');
    const sigTriggers = parsed.triggers.filter(t => t.type === 'signal');
    const evTriggers = parsed.triggers.filter(t => t.type === 'event' || t.type === 'special');

    // helper to apply value -> element prop
    const applyToElement = (val, propPath) => {
      const prop = propPath || getAutoProp(el);
      try {
        if(prop === 'checked') el.checked = Boolean(val);
        else if(prop === 'value') el.value = val == null ? '' : val;
        else el.textContent = val == null ? '' : val;
      } catch(e) { console.error('Failed to apply sync value', e); }
    };

    // subscribe to signal -> element (one-way or part of two-way)
    if(sigTriggers.length > 0 || (sigTargets.length > 0 && evTriggers.length === 0)){
      // which signals to subscribe: use triggers (with mods) if present, otherwise targets
          if(sigTriggers.length){
        for(const t of sigTriggers){
          const sname = t.name;
          const rootRaw = String(sname).split('.')[0];
          const rootBase = (rootRaw.indexOf('[') !== -1) ? rootRaw.split('[')[0] : rootRaw;
          const root = toCamel(rootBase);
          const handler = () => {
            try{ const v = get(String(sname));
              const pt = propTargets.length ? (propTargets[0].propPath || null) : null;
              applyToElement(v, pt);
            }catch(e){}
          };
          handler();
          if(!subs.has(root)) subs.set(root, []);
          const rootAlias = sigKey(rootBase);
          if(rootAlias !== root && !subs.has(rootAlias)) subs.set(rootAlias, []);
          let entry = handler;
          if(t.mods && ('shape' in t.mods || 'content' in t.mods)){
            const sval = (t.mods && 'shape' in t.mods) ? ((t.mods.shape === true || t.mods.shape === 1) ? null : (t.mods.shape != null ? String(t.mods.shape) : null)) : null;
            entry = { fn: handler, mode: ('shape' in t.mods ? 'shape' : 'content'), childPath: sval };
          }
          subs.get(root).push(entry);
          if(rootAlias !== root) subs.get(rootAlias).push(entry);
          let listeners = cleanupMap.get(el); if(!listeners) listeners = [], cleanupMap.set(el, listeners);
          listeners.push({type:'signal', root, handler});
          if(rootAlias !== root) listeners.push({type:'signal', root: rootAlias, handler});
        }
      } else {
        const subsigs = sigTargets.map(t=>t.name);
        for(const sname of subsigs){
          const rootRaw = String(sname).split('.')[0];
          const rootBase = (rootRaw.indexOf('[') !== -1) ? rootRaw.split('[')[0] : rootRaw;
          const root = toCamel(rootBase);
          const handler = () => {
            try{ const v = get(String(sname));
              const pt = propTargets.length ? (propTargets[0].propPath || null) : null;
              applyToElement(v, pt);
            }catch(e){}
          };
          handler();
          if(!subs.has(root)) subs.set(root, []);
          const rootAlias = sigKey(rootBase);
          if(rootAlias !== root && !subs.has(rootAlias)) subs.set(rootAlias, []);
          subs.get(root).push(handler);
          if(rootAlias !== root) subs.get(rootAlias).push(handler);
          let listeners = cleanupMap.get(el); if(!listeners) listeners = [], cleanupMap.set(el, listeners);
          listeners.push({type:'signal', root, handler});
          if(rootAlias !== root) listeners.push({type:'signal', root: rootAlias, handler});
        }
      }
    }

    // element -> signal (one-way) when event triggers are present or for two-way
    if(sigTargets.length > 0){
      // if there are explicit evTriggers, use those for write; if none and we subscribed above, set up default write as well for two-way
      const shouldWriteOnEvent = evTriggers.length > 0 || (evTriggers.length === 0 && parsed.triggers.length === 0);
      if(shouldWriteOnEvent){
        const targetSig = sigTargets[0].name;
        const evs = evTriggers.length ? evTriggers : [{type:'event', elemId:'', eventName: null, isCurr:true}];
        for(const ev of evs){
          // attach to current element or specific element
          const targetEl = ev.elemId ? getElById(ev.elemId, attr) : el;
          if(!targetEl) continue;
          // If the trigger's eventName looks like a property (e.g. 'value' or 'checked')
          // treat it as a prop selector and listen on the element's default event instead.
          let finalEventName = ev.eventName || getAutoEvent(targetEl);
          let propSelector = null;
          if(ev.isCurr && ev.eventName){
            const candidate = ev.eventName;
            const defaultProp = getAutoProp(targetEl);
            if(candidate === defaultProp || candidate === 'value' || candidate === 'checked' || candidate === 'textContent'){
              propSelector = candidate;
              finalEventName = getAutoEvent(targetEl);
            }
          }
          const handler = () => {
            try{
              const prop = (propTargets.length ? (propTargets[0].propPath || getAutoProp(el)) : (propSelector || getAutoProp(targetEl)));
              const val = (prop === 'checked') ? targetEl.checked : (prop === 'value' ? targetEl.value : targetEl.textContent);
              set(String(targetSig), val);
            }catch(e){}
          };
          targetEl.addEventListener(finalEventName, handler);
          let listeners = cleanupMap.get(targetEl); if(!listeners) listeners = [], cleanupMap.set(targetEl, listeners);
          listeners.push({type:'event', targetEl, eventName: finalEventName, handler});
        }
      }
    }
  }

  // data-dump implementation: clone a template per array item or once for an object
  function setupDump(el, attrName, attrVal) {
    // Parse attribute tokens from either the attribute NAME or attribute VALUE
    // Syntax variations supported:
    // - data-dump@posts#tpl-id
    // - data-dump#tpl-id@posts
    // - <ul data-dump@posts> <template>...</template></ul>
    const parseDumpAttr = (name, val) => {
      let sig = null, tplId = null;
      const scan = (s) => {
        if(!s) return;
        const atIdx = s.indexOf('@');
        const hashIdx = s.indexOf('#');
        if(atIdx !== -1){ sig = s.slice(atIdx + 1).split('#')[0] || sig; }
        if(hashIdx !== -1){ tplId = s.slice(hashIdx + 1).split('@')[0] || tplId; }
        // If string looks like a bare signal name (no @/#), accept it when no sig yet
        if(sig == null){ const trimmed = s.trim(); if(trimmed && /^[A-Za-z0-9_\.-]+$/.test(trimmed)) sig = sig || trimmed; }
      };
      scan(name); scan(val);
      return { sig, tplId };
    };

    const parsed = parseDumpAttr(attrName || '', attrVal || '');
    // parsed attribute tokens (no debug log)
    let sig = parsed.sig || null;
    let tplId = parsed.tplId || null;
    // if no tplId, look for a child <template>
    let tpl = null;
    if(tplId) tpl = getElById(tplId, attrName);
    if(!tpl){ tpl = el.querySelector('template'); }
    // If template was an inline child, detach it so it doesn't remain as a DOM child
    if(tpl && tpl.parentNode === el){ tpl.parentNode.removeChild(tpl); }
    if(!tpl) return; // nothing to render
    if(!sig) {
      // try to read a 'data-signal' attribute or the element's value as fallback
      if(el.getAttribute && el.getAttribute('data-signal')) sig = el.getAttribute('data-signal');
      if(!sig && attrVal && attrVal.trim()) sig = attrVal.trim();
      // Additional fallback: scan element attribute NAMES and re-parse the full attribute name
      if(!sig && el.getAttributeNames){
        const names = el.getAttributeNames();
        for(const an of names){
          if(typeof an === 'string' && an.indexOf('data-dump') === 0){
            const reparsed = parseDumpAttr(an, el.getAttribute(an));
            if(reparsed.sig){ sig = reparsed.sig; tplId = tplId || reparsed.tplId; break; }
          }
        }
      }
      if(!sig) return; // still none
    }

    // canonical root
    const root = toCamel(sig.split('.')[0]);
    const rootAlias = sigKey(sig.split('.')[0]);

    // internal state on element
    if(!el.__dump) el.__dump = { nodes: [], count: 0, sig: sig };

    const doRender = (ev, p, detail) => {
      const val = get(sig || '');
      // If value is an array, render one clone per item; if object, render single
      if(Array.isArray(val)){
        const newLen = val.length;
        const oldLen = el.__dump.count || 0;
        // remove from end if items removed
        if(newLen < oldLen){
          const removeCount = oldLen - newLen;
          for(let i=0;i<removeCount;i++){
            const node = el.__dump.nodes.pop();
            if(node && node.parentNode) node.parentNode.removeChild(node);
          }
          el.__dump.count = newLen;
        }
        // add new clones at end if increased
        if(newLen > oldLen){
          const frag = document.createDocumentFragment();
          for(let idx = oldLen; idx < newLen; idx++){
            try{
              if(!tpl.content || !tpl.content.firstElementChild){ break; }
              const node = tpl.content.firstElementChild.cloneNode(true);
            // replace placeholders in attribute NAMES: $item -> sig.idx (e.g. posts.0), $index -> idx
            const walk = [node].concat(Array.from(node.querySelectorAll('*')));
            for(const n of walk){
              const attrs = Array.from(n.attributes || []);
              for(const a of attrs){
                const origName = a.name;
                const origVal = a.value;
                let name = origName;
                let value = origVal;
                // Replace placeholders in attribute NAMES
                if(name.indexOf('$item') !== -1 || name.indexOf('$index') !== -1){
                  const newName = name.replace(/\$item/g, sig + '.' + idx).replace(/\$index/g, String(idx));
                  if(newName !== name){ name = newName; }
                }
                // Replace placeholders in attribute VALUES (JS expressions)
                if(typeof value === 'string' && (value.indexOf('$item') !== -1 || value.indexOf('$index') !== -1)){
                  value = value.replace(/\$index/g, String(idx)).replace(/\$item/g, ('dm.' + sig + '[' + idx + ']'));
                }
                // apply possibly-updated name/value
                try{
                  n.removeAttribute(origName);
                  n.setAttribute(name, value);
                }catch(e){}
              }
            }
            // Evaluate simple `data-sub` expressions now so clones show initial content
            try{
              for(const n2 of walk){
                for(const a2 of Array.from(n2.attributes || [])){
                  const an2 = a2.name; const v2 = a2.value;
                  if(an2.indexOf('data-sub') === 0){
                    try{
                      const fn = compile(v2);
                      const res = fn(dmProxy, n2, undefined, sig);
                      // set default property (textContent/value) for the element
                      try{ setProp(n2, null, res); }catch(e){}
                    }catch(e){}
                  }
                }
              }
            }catch(e){}
            // nested rendering: if item has `replies` array, append a small ul into placeholders
            try {
              const item = val[idx];
              if(item && Array.isArray(item.replies)){
                const sub = document.createElement('ul');
                for(const r of item.replies){
                  const li = document.createElement('li'); li.textContent = r; sub.appendChild(li);
                }
                node.querySelectorAll('.replies-placeholder').forEach(ph => ph.appendChild(sub));
              }
            } catch(e) {}
            frag.appendChild(node);
            el.__dump.nodes.push(node);
            }catch(e){}
          }
          el.appendChild(frag);
          // After insertion, wire up data-* attributes inside newly added nodes
          for(const node of el.__dump.nodes.slice(- (newLen - oldLen))){
            const walk2 = [node].concat(Array.from(node.querySelectorAll('*')));
            for(const n of walk2){
              for(const a of Array.from(n.attributes || [])){
                const an = a.name;
                const v = a.value;
                if(an.indexOf('data-sub') === 0) setupSub(n, an, v);
                else if(an.indexOf('data-sync') === 0) setupSync(n, an);
                else if(an.indexOf('data-class') === 0) setupClass(n, an, v);
                else if(an.indexOf('data-disp') === 0) setupDisp(n, an, v);
                else if(an.indexOf('data-dump') === 0) setupDump(n, an, v);
                else if(an.indexOf('data-get') === 0 || an.indexOf('data-post') === 0 || an.indexOf('data-put') === 0 || an.indexOf('data-patch') === 0 || an.indexOf('data-delete') === 0) setupAction(n, an, v);
              }
            }
          }
            
          el.__dump.count = newLen;
        }
      } else if(val && typeof val === 'object'){
        // object: render once (replace existing)
        // clear previous nodes
        while(el.firstChild) el.removeChild(el.firstChild);
        el.__dump.nodes = [];
        const node = tpl.content.firstElementChild.cloneNode(true);
        const walk = [node].concat(Array.from(node.querySelectorAll('*')));
        for(const n of walk){
          const attrs = Array.from(n.attributes || []);
          for(const a of attrs){
            const origName = a.name; const origVal = a.value;
            let name = origName; let value = origVal;
            if(name.indexOf('$item') !== -1) { name = name.replace(/\$item/g, sig); }
            if(typeof value === 'string' && (value.indexOf('$item') !== -1 || value.indexOf('$index') !== -1)){
              value = value.replace(/\$index/g, '0').replace(/\$item/g, ('dm.' + sig));
            }
            try{ n.removeAttribute(origName); }catch(e){}
            n.setAttribute(name, value);
          }
        }
        el.appendChild(node);
        // wire up attributes
        const walk2 = [node].concat(Array.from(node.querySelectorAll('*')));
        for(const n of walk2){
          for(const a of Array.from(n.attributes || [])){
            const an = a.name; const v = a.value;
            if(an.indexOf('data-sub') === 0) setupSub(n, an, v);
            else if(an.indexOf('data-sync') === 0) setupSync(n, an);
            else if(an.indexOf('data-class') === 0) setupClass(n, an, v);
            else if(an.indexOf('data-disp') === 0) setupDisp(n, an, v);
            else if(an.indexOf('data-get') === 0 || an.indexOf('data-post') === 0 || an.indexOf('data-put') === 0 || an.indexOf('data-patch') === 0 || an.indexOf('data-delete') === 0) setupAction(n, an, v);
          }
        }
        el.__dump.count = 1;
        el.__dump.nodes.push(node);
      } else {
        // empty or null: clear
        while(el.firstChild) el.removeChild(el.firstChild);
        el.__dump.nodes = []; el.__dump.count = 0;
      }
    };

    // subscribe to root signal (shape mode)
    if(!subs.has(root)) subs.set(root, []);
    if(rootAlias !== root && !subs.has(rootAlias)) subs.set(rootAlias, []);
    const entry = { fn: doRender, mode: 'shape', childPath: null };
    subs.get(root).push(entry);
    if(rootAlias !== root) subs.get(rootAlias).push(entry);

    // initial render
    try{ doRender(undefined, sig); }catch(e){}
  }

  // --- Modifiers demo helpers: none (logic implemented in setupGeneric above)

  // Signal get/set/emit
  const get = p => {
    const parts = p.split('.');
    let v = S.get(toCamel(parts[0]));
    for(let i = 1; i < parts.length; i++) v = v?.[toCamel(parts[i])];
    return v;
  };
  // Diff helper: compares two objects or arrays shallowly and returns change details
  // NOTE: key-level value-change entries were removed: shape diffs only report added/removed keys/indices.
  const diffValues = (before, after, includeVals = false) => {
    const out = { added: [], removed: [] };
    if(includeVals){ out.addedValues = {}; out.removedValues = {}; }
    if(before == null && after == null) return out;
    if(Array.isArray(before) || Array.isArray(after)){
      const a = Array.isArray(before) ? before : [];
      const b = Array.isArray(after) ? after : [];
      if(b.length > a.length){
        for(let i = a.length; i < b.length; i++){ out.added.push(i); if(includeVals) out.addedValues[i] = b[i]; }
      } else if(b.length < a.length){
        for(let i = b.length; i < a.length; i++){ out.removed.push(i); if(includeVals) out.removedValues[i] = a[i]; }
      }
      // value changes within existing indices are considered content (not shape) and are not reported here
      return out;
    }
    // objects
    const bb = before && typeof before === 'object' ? before : {};
    const aa = after && typeof after === 'object' ? after : {};
    for(const k in aa){ if(!(k in bb)){ out.added.push(k); if(includeVals) out.addedValues[k] = aa[k]; } }
    for(const k in bb){ if(!(k in aa)){ out.removed.push(k); if(includeVals) out.removedValues[k] = bb[k]; } }
    // property value changes are considered content-only and are not included in shape diffs
    return out;
  };
  const emit = (p, mutation = 'content', info = null) => {
    const root = toCamel(p.split('.')[0]);
    const handlers = subs.get(root);
    
    if(handlers){
      for(const h of handlers){
        try{
          // Legacy function handlers (fast path) for content and shape
          if(typeof h === 'function'){
            h(undefined, p);
            continue;
          }
          if(!(h && typeof h.fn === 'function')) continue;

          // CONTENT mutation: only call content-mode subscribers (fast path)
          if(mutation === 'content'){
            if(h.mode === 'content' && !h.childPath){ h.fn(undefined, p); }
            continue;
          }

          // SHAPE mutation: prepare minimal change payload (added/removed only)
          if(h.mode === 'shape' || h.mode === 'content'){
            const base = info && info.base ? info.base : { added: [], removed: [] };
            const change = { added: base.added || [], removed: base.removed || [] };

            // If subscriber requested a childPath filter, only invoke when that key/index was added/removed
            const cp = h.childPath != null ? String(h.childPath) : null;
            if(cp){
              const sval = cp;
              const svalCamel = toCamel(sval);
              const makeKeySet = (list) => {
                const s = new Set();
                (list || []).forEach(x => { const sx = String(x); s.add(sx); s.add(toCamel(sx)); const nx = Number(x); if(!Number.isNaN(nx)) s.add(String(nx)); });
                return s;
              };
              const addedSet = makeKeySet(change.added);
              const removedSet = makeKeySet(change.removed);
              const matches = addedSet.has(sval) || addedSet.has(svalCamel) || removedSet.has(sval) || removedSet.has(svalCamel);
              if(!matches) continue;
            }

            // For signal-originated invocations, pass no event object (undefined)
            // and forward the minimal change summary as a third argument (`detail`).
            // This makes handlers treat `ev` as undefined (signal source) and
            // receive the change via the `detail` parameter.
            h.fn(undefined, p, change);
          }
        }catch(e){ console.error('Subscriber handler error', e); }
      }
    }
    updateDebug();
  };

  // Phase 1.2: Infinite loop guard for set()
  let syncDepth = 0;
  const MAX_SYNC_DEPTH = 10;

  const set = (p, v, force = false) => {
    // Phase 1.2: Guard against infinite loops
    if (syncDepth > MAX_SYNC_DEPTH) {
      console.error(`[dmax] Infinite loop detected for signal: ${p} (depth > ${MAX_SYNC_DEPTH})`);
      return;
    }
    syncDepth++;
    try {
      return setImpl(p, v, force);
    } finally {
      syncDepth--;
    }
  };

  const setImpl = (p, v, force = false) => {
    const parts = p.split('.');
    const root = toCamel(parts[0]);
    const current = get(p);
    // quick equality for primitives and references
  if (!force && current === v) return;
    // helper to detect shape vs content
    const detectMutation = () => {
      if(parts.length === 1){
        // root-level assignment: treat object/array assignments as shape (structural)
        if(v && typeof v === 'object') return 'shape';
        return 'content';
      }
      const parentPath = parts.slice(0, -1).join('.') ;
      const parent = get(parentPath);
      const lastRaw = parts[parts.length - 1];
      const lastIsIndex = /^\d+$/.test(String(lastRaw));
      const last = lastIsIndex ? +lastRaw : toCamel(lastRaw);
      if(parent == null) return 'shape';
      if(Array.isArray(parent)){
        if(lastIsIndex){
          if(last >= parent.length) return 'shape'; // adding index -> shape
          return 'content'; // replacing existing index -> content
        }
        // non-numeric assignment on array -> shape
        return 'shape';
      }
      // object parent
      if(Object.prototype.hasOwnProperty.call(parent, last)) return 'content';
      return 'shape';
    };

    const mutation = detectMutation();

    // prepare change info for shape mutations
    let changeInfo = null;
    if(parts.length === 1){
      const before = S.get(root);
      S.set(root, v);
      try{ const alias = sigKey(root); if(alias !== root) S.set(alias, v); }catch(e){}
      if(mutation === 'shape'){
        // diff top-level object/array
        const base = diffValues(before, v, false);
        const full = diffValues(before, v, true);
        changeInfo = { base, full };
      }
    } else {
      // structural shallow clone: only clone root object/array and walk path
      const orig = S.get(root);
      // compute parent path and before-parent snapshot
      const parentPath = parts.slice(0, -1).join('.');
      const beforeParent = get(parentPath);
      let base;
      try{ base = Array.isArray(orig) ? orig.slice() : (orig && typeof orig === 'object' ? Object.assign({}, orig) : (typeof orig === 'object' ? {} : {})); }catch(e){ base = {} }
      let t = base;
      for(let i = 1; i < parts.length - 1; i++){
        const key = toCamel(parts[i]);
        if(typeof t[key] !== 'object' || t[key] === null) t[key] = {};
        // shallow clone child to avoid mutating original reference
        const child = t[key];
        t[key] = Array.isArray(child) ? child.slice() : Object.assign({}, child);
        t = t[key];
      }
      t[toCamel(parts[parts.length - 1])] = v;
      // after-parent snapshot
      const afterParent = (function(){
        let node = base;
        for(let i = 1; i < parts.length - 1; i++) node = node[toCamel(parts[i])] || {};
        return node;
      })();
      S.set(root, base);
      try{ const alias = sigKey(root); if(alias !== root) S.set(alias, base); }catch(e){}
      if(mutation === 'shape'){
        const base = diffValues(beforeParent, afterParent, false);
        const full = diffValues(beforeParent, afterParent, true);
        changeInfo = { base, full };
      }
    }
    emit(p, mutation, changeInfo);
  };

  // Debug update
  const updateDebug = () => {
    if(debug) debug.textContent = JSON.stringify(Object.fromEntries(S), null, 2);
  };

  // Phase 3a.2: setupDef extracted for single-pass init
  function setupDef(el, attr, value) {
    const colonIdx = attr.indexOf(':');
    const name = colonIdx === -1 ? '' : attr.substring(colonIdx + 1);
    const camelName = toCamel(name);
    if(camelName === 'ev' || camelName === 'el'){
      console.error('Reserved signal name:', name); return;
    }
    if(!name){
      const o = JSON.parse(value);
      for(let k in o){
        const camelK = toCamel(k);
        if(camelK === 'ev' || camelK === 'el'){
          console.error('Reserved signal name:', k); continue;
        }
        S.set(camelK, o[k]);
        try{ const alias = sigKey(camelK); if(alias !== camelK) S.set(alias, o[k]); }catch(e){}
      }
    } else {
      S.set(camelName, Function('return ' + value)());
      try{ const alias = sigKey(camelName); if(alias !== camelName) S.set(alias, Function('return ' + value)()); }catch(e){}
    }
  }

  // Directive handler registry for extensibility
  const DIRECTIVE_HANDLERS = {
    'data-def': setupDef,
    'data-sync': setupSync,
    'data-sub': setupSub,
    'data-class': setupClass,
    'data-disp': setupDisp,
    'data-dump': setupDump,
    'data-get': setupAction,
    'data-post': setupAction,
    'data-put': setupAction,
    'data-patch': setupAction,
    'data-delete': setupAction
  };

  // Init: single-pass DOM traversal with directive table
  const init = () => {
    const defs = [], directives = [];
    
    // Single DOM query and attribute scan
    document.querySelectorAll('*').forEach(el => {
      for(const a of el.attributes){
        const attrName = a.name;
        // Check for data-def first (needs to run before others)
        if(attrName === 'data-def' || attrName.indexOf('data-def:') === 0){
          defs.push([el, attrName, a.value]);
          continue;
        }
        // Check directive handlers table
        // For action attributes (data-get/post/etc), extract base before any modifier chars
        const prefix = attrName.split(/[_:@^+?]/)[0];
        const handler = DIRECTIVE_HANDLERS[prefix];
        if(handler){
          directives.push([el, attrName, a.value, handler]);
        }
      }
    });
    
    // Execute definitions first
    defs.forEach(([el, attr, value]) => setupDef(el, attr, value));
    
    // Execute directives
    directives.forEach(([el, attr, value, handler]) => handler(el, attr, value));
    // Extra sweep: ensure any elements with attributes named `data-dump*` are initialized
    try{
      const all2 = document.querySelectorAll('*');
      all2.forEach(el => {
        if(!el.getAttributeNames) return;
        for(const an of el.getAttributeNames()){
          if(typeof an === 'string' && an.indexOf('data-dump') === 0){
            try{ setupDump(el, an, el.getAttribute(an)); }catch(e){}
          }
        }
      });
    }catch(e){}
    updateDebug();
  };
  if(document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', init);
  } else {
    init();
  }
  // expose state for headless tests/debugging
  window.__getState = () => Object.fromEntries(S);
})();
</script>


<section>
  <h3>11. Content vs Shape Demo</h3>
  <div class="page">Demonstrates default (content) subscriptions vs <code>__shape</code> subscriptions.</div>
  <div style="margin:8px 0;padding:8px;border:1px solid #eee;border-radius:6px">
    <div>Parent signal preview:</div>
    <pre id="demoState" style="background:#fafafa;padding:8px;border-radius:4px" data-sub:.@demo-parent="JSON.stringify(dm.demoParent, null, 2)"></pre>
    <div style="margin-top:6px">
      <button id="demoAddKey" data-sub:demo-parent@.click="Object.assign({}, dm.demoParent || {}, {addedAt: Date.now()})">Add key (shape)</button>
      <button id="demoRemoveKey" data-sub:demo-parent@.click="(function(){ const o = Object.assign({}, dm.demoParent || {}); delete o.addedAt; return o; })()">Remove key (shape)</button>
      <button id="demoChangeChild" data-sub:demo-parent.child@.click="(dm.demoParent && dm.demoParent.child ? dm.demoParent.child + 1 : 1)">Change child (content)</button>
    </div>
    <div style="margin-top:8px">
      <div>Content subscriber (default): <span id="demoContent" data-sub:.@demo-parent.child="String(dm.demoParent && dm.demoParent.child) || ''"></span></div>
      <div>Shape subscriber (<code>__shape</code>): <span id="demoShape" data-sub:.@demo-parent__shape="(ev && ev.detail && ev.detail.change) ? window.formatShapeChange(ev.detail.change) : (detail ? window.formatShapeChange(detail) : '')"></span></div>
      
      <pre id="testShapeProbe" style="display:none" data-sub:.@demo-parent__shape="(function(){ window.__probe_ev = ev; window.__probe_sg = sg; window.__probe_detail = detail; return ''; })()"></pre>
    </div>
  </div>
</section>

<script>
// Helper to render shape change summaries for the demo
window.formatShapeChange = function(c){
  if(!c) return '';
  const ch = (c && (c.added || c.removed)) ? c : (c && (c.base || c.full) ? c.base || c.full : c);
  const parts = [];
  if(ch.added && ch.added.length) parts.push('added: ' + ch.added.join(','));
  if(ch.removed && ch.removed.length) parts.push('removed: ' + ch.removed.join(','));
  // key-level value changes are considered content-only and are not reported in shape summaries
  if(parts.length === 0) return '';
  return parts.join(' | ');
};
</script>


<div id="__fg_reactivity_tests" style="display:none">
  <span id="contentSub" data-sub:.@parent="(window.__contentCount = (window.__contentCount||0) + 1, window.__contentCount)"></span>
  <span id="shapeSub" data-sub:.@parent__shape="(window.__shapeCount = (window.__shapeCount||0) + 1, window.__shapeCount)"></span>
  <span id="shapeChild" data-sub:.@parent__shape="(window.__shapeChild = (window.__shapeChild||0) + 1, window.__shapeChild)"></span>

  
  <span id="indirectCount" data-sub:.@postObjs[idx]="(window.__indirectCount=(window.__indirectCount||0)+1,window.__indirectCount)"></span>
  <button id="setPost0Title" data-sub:postObjs.0.title@.click="'NewP0Title'">Set post0 title</button>
  <button id="setPost1Title" data-sub:postObjs.1.title@.click="'NewP1Title'">Set post1 title</button>
  <button id="setIdx1" data-sub:idx@.click="1">Set idx to 1</button>

  <button id="chgChild" data-sub:parent.child@.click="(dm.parent && dm.parent.child ? dm.parent.child + 1 : 1)">Change child</button>
  <button id="addKey" data-sub:parent@.click="Object.assign({}, dm.parent || {}, {added: true})">Add key</button>
  <button id="removeKey" data-sub:parent@.click="(function(){ const o = Object.assign({}, dm.parent || {}); delete o.added; return o; })()">Remove key</button>
</div>

</body>
</html>
