// Smaller table-FSM parser: compact, minimal allocations
function pmods(s,i){const n=s.length,m={};while(i+1<n&&s[i]=='_'&&s[i+1]=='_'){i+=2;let j=i;while(j<n&&'.:@_'.indexOf(s[j])===-1)j++;let name=s.slice(i,j);if(!name)return[null,i];i=j;let val=1;if(i<n&&s[i]=='.'){i++;let k=i;while(k<n&&':@_'.indexOf(s[k])===-1)k++;let raw=s.slice(i,k);i=k;val=raw!==''&&!isNaN(Number(raw))?+raw:raw}m[name]=val}return[m,i]}
function norm(p){if(!p)return null;for(let i=0;i<p.length;i++)if(p.charCodeAt(i)>=65&&p.charCodeAt(i)<=90)return null;return p}
function parseDataAttrTable(s,p){const n=s.length;let i=p;let gm={};if(i+1<n&&s[i]=='_'&&s[i+1]=='_'){const r=pmods(s,i);if(r[0]===null)return null;gm=r[0];i=r[1]}const T=[],X=[];while(i<n){const c=s[i];if(c==':'){i++;if(i>=n)return null;const c2=s[i];if(c2=='#'){i++;let j=i;while(j<n&&'.:@_'.indexOf(s[j])===-1)j++;const id=s.slice(i,j);i=j;let prop=null;if(i<n&&s[i]=='.'){i++;let k=i;while(k<n&&':@'.indexOf(s[k])===-1)k++;let raw=s.slice(i,k);if(raw){const mi=raw.indexOf('__');if(mi!=-1)raw=raw.slice(0,mi)}prop=raw?norm(raw):null;if(prop===null&&raw!==null)return null}let mr=[{},i];if(i+1<n&&s[i]=='_'&&s[i+1]=='_')mr=pmods(s,i);if(mr[0]===null)return null;i=mr[1];T.push({type:'prop',elemId:id,propPath:prop,isCurr:false,mods:Object.assign({},gm,mr[0])})
}else if(c2=='.'){i++;let j=i;while(j<n&&'.:@_'.indexOf(s[j])===-1)j++;let raw=s.slice(i,j);i=j;let nm=raw||null;if(nm){const mi=nm.indexOf('__');if(mi!=-1)nm=nm.slice(0,mi)}const prop=nm?norm(nm):null;if(prop===null&&nm!==null)return null;let mr=[{},i];if(i+1<n&&s[i]=='_'&&s[i+1]=='_')mr=pmods(s,i);if(mr[0]===null)return null;i=mr[1];T.push({type:'prop',elemId:'',propPath:prop,isCurr:true,mods:Object.assign({},gm,mr[0])})
}else{let j=i;while(j<n&&':@_'.indexOf(s[j])===-1)j++;let raw=s.slice(i,j);i=j;if(!raw)return null;const mi=raw.indexOf('__');if(mi!=-1)raw=raw.slice(0,mi);const name=norm(raw);if(name===null)return null;let mr=[{},i];if(i+1<n&&s[i]=='_'&&s[i+1]=='_')mr=pmods(s,i);if(mr[0]===null)return null;i=mr[1];T.push({type:'signal',name,mods:Object.assign({},gm,mr[0])})}}else if(c=='@'){i++;if(i>=n)return null;const c2=s[i];if(c2=='_'){i++;let j=i;while(j<n&&'.:@_'.indexOf(s[j])===-1)j++;let tok=s.slice(i,j);i=j;if(!tok)return null;let arg=null;if(i<n&&s[i]=='.'){i++;let k=i;while(k<n&&':@_'.indexOf(s[k])===-1)k++;arg=s.slice(i,k)||null;i=k}let mr=[{},i];if(i+1<n&&s[i]=='_'&&s[i+1]=='_')mr=pmods(s,i);if(mr[0]===null)return null;i=mr[1];X.push({type:'special',name:tok,arg,mods:Object.assign({},gm,mr[0])})
}else if(c2=='#'){i++;let j=i;while(j<n&&'.:@_'.indexOf(s[j])===-1)j++;let id=s.slice(i,j);i=j;let ev=null;if(i<n&&s[i]=='.'){i++;let k=i;while(k<n&&':@'.indexOf(s[k])===-1)k++;let raw=s.slice(i,k);ev=raw?norm(raw):null;if(ev===null&&raw!==null)return null;i=k}let mr=[{},i];if(i+1<n&&s[i]=='_'&&s[i+1]=='_')mr=pmods(s,i);if(mr[0]===null)return null;i=mr[1];X.push({type:'event',elemId:id,eventName:ev,isCurr:false,mods:Object.assign({},gm,mr[0])})
}else if(c2=='.'){i++;let j=i;while(j<n&&':@_'.indexOf(s[j])===-1)j++;let raw=s.slice(i,j);i=j;let ev=raw?norm(raw):null;if(ev===null&&raw!==null)return null;let mr=[{},i];if(i+1<n&&s[i]=='_'&&s[i+1]=='_')mr=pmods(s,i);if(mr[0]===null)return null;i=mr[1];X.push({type:'event',elemId:'',eventName:ev,isCurr:true,mods:Object.assign({},gm,mr[0])})
}else{let j=i;while(j<n&&':@_'.indexOf(s[j])===-1)j++;let raw=s.slice(i,j);i=j;if(!raw)return null;let name=norm(raw);if(name===null)return null;let mr=[{},i];if(i+1<n&&s[i]=='_'&&s[i+1]=='_')mr=pmods(s,i);if(mr[0]===null)return null;i=mr[1];X.push({type:'signal',name,mods:Object.assign({},gm,mr[0])})
}}else return null;if(i<n&&s[i]!==':'&&s[i]!=='@')return null}
if(!T.length&&!X.length)return null;return{targets:T,triggers:X}}

module.exports={parseDataAttrTable}
